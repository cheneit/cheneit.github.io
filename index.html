<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Repo Library â€” Admin + Preview</title>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ["Inter", "ui-sans-serif", "system-ui", "-apple-system", "BlinkMacSystemFont", "\"Segoe UI\"", "Roboto", "\"Helvetica Neue\"", "Arial", "\"Noto Sans\"", "sans-serif", "\"Apple Color Emoji\"", "\"Segoe UI Emoji\"", "\"Segoe UI Symbol\""] },
          boxShadow: { soft: "0 10px 30px rgba(0,0,0,0.08)" },
        },
      },
    };
  </script>
  <!-- React + ReactDOM + Babel -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
</head>
<body class="bg-slate-50">
<div id="root"></div>

<script type="text/babel">
  const { useState, useEffect, useMemo, useRef } = React;

  /**
   * =========================
   * Single-file SPA for a GitHub-hosted repo library
   * - Admin mode: configure repo + upload / edit / delete items
   * - Preview mode: search / filter / preview files (code, text, pdf link)
   *   Admin UI is protected by password (AuthGate)
   * =========================
   */

  // ----------- å°å·¥å…·å‡½æ•° -----------

  function b64EncodeUint8(arr) {
    let binary = '';
    const len = arr.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(arr[i]);
    }
    return btoa(binary);
  }

  function isAbsoluteUrl(path) {
    return /^https?:\/\//i.test(path);
  }

  function ghRawUrl({ owner, repo, branch, path }) {
    return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;
  }

  function buildRawUrl(cfg, path) {
    if (!path) return '#';
    if (isAbsoluteUrl(path)) return path;
    return ghRawUrl({ owner: cfg.owner, repo: cfg.repo, branch: cfg.branch, path });
  }

  // ä¸“é—¨ç»™ PDF åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ç”¨ï¼š
  // - å¯¹ github.com/.../blob/... é“¾æ¥ï¼Œæˆªå‡º /uploads/... æˆ– /data/files/... è¿™æ®µè·¯å¾„
  // - å¯¹ raw.githubusercontent.com é“¾æ¥ï¼Œæˆªå‡ºä»“åº“é‡Œçš„ç›¸å¯¹è·¯å¾„
  // - å¯¹ç›¸å¯¹è·¯å¾„ï¼ˆuploads/... æˆ– data/files/...ï¼‰ï¼ŒåŠ ä¸Šå‰å¯¼æ–œæ å˜æˆ /uploads/... è¿™æ ·çš„ç«™ç‚¹è·¯å¾„
  // - å¯¹å…¶ä»–åŸŸåçš„ç»å¯¹ URLï¼Œä¿æŒåŸæ ·
  function buildPdfBrowserUrl(path) {
      if (!path) return '#';

    try {
      const u = new URL(path);
      const host = u.hostname;
      const pathname = u.pathname;

      // 1) https://github.com/<owner>/<repo>/blob/<ref>/<path...>
      if (host === 'github.com') {
        const blobIndex = pathname.indexOf('/blob/');
        if (blobIndex !== -1) {
          const afterBlob = pathname.substring(blobIndex + '/blob/'.length); // "<ref>/<rest>"
          const firstSlash = afterBlob.indexOf('/');
          if (firstSlash !== -1) {
            const rest = afterBlob.substring(firstSlash + 1); // "uploads/2025/10/xxx.pdf"
            return '/' + rest;
          }
        }
        // æ‰¾ä¸åˆ° blobï¼Œå°±é€€è€Œæ±‚å…¶æ¬¡ç”¨åŸå§‹ pathname
        return pathname;
      }

      // 2) https://raw.githubusercontent.com/<owner>/<repo>/<branch>/<path...>
      if (host === 'raw.githubusercontent.com') {
        const parts = pathname.split('/').filter(Boolean);
        if (parts.length >= 4) {
          const rest = parts.slice(3).join('/'); // ä»ç¬¬å››æ®µå¼€å§‹æ˜¯ä»“åº“å†…éƒ¨çš„è·¯å¾„
          return '/' + rest;
        }
        return pathname;
      }

      // 3) å…¶ä»–åŸŸåçš„ç»å¯¹ URLï¼šä¸åšå¤„ç†ï¼Œç›´æ¥ç”¨
      return path;
    } catch (e) {
      // 4) ä¸æ˜¯ç»å¯¹ URLï¼Œå½“ä½œä»“åº“æ ¹ç›®å½•ä¸‹çš„ç›¸å¯¹è·¯å¾„
      if (path.startsWith('/')) return path;
      return '/' + path;
    }
  }

  async function ghGetJSONRaw(cfg, path) {
    const url = buildRawUrl(cfg, path);
    const res = await fetch(url);
    if (!res.ok) return null;
    return await res.json();
  }

  async function ghGetTextRaw(cfg, path) {
    const url = buildRawUrl(cfg, path);
    const res = await fetch(url);
    if (!res.ok) return null;
    return await res.text();
  }

  async function ghGetBlobRaw(cfg, path) {
    const url = buildRawUrl(cfg, path);
    const res = await fetch(url);
    if (!res.ok) return null;
    return await res.blob();
  }

  async function ghGetContentMeta(cfg, path, token) {
    const url = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${path}`;
    const res = await fetch(url, {
      headers: {
        ...(token ? { Authorization: `Bearer ${token}` } : {})
      }
    });
    if (res.status === 404) return null;
    if (!res.ok) {
      const txt = await res.text();
      throw new Error(`GitHub API error: ${res.status} ${res.statusText} - ${txt}`);
    }
    return res.json();
  }

  async function ghPutContent(cfg, path, b64Content, message, token, sha) {
    const url = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${path}`;
    const body = { message, content: b64Content };
    if (sha) body.sha = sha;
    const res = await fetch(url, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...(token ? { Authorization: `Bearer ${token}` } : {})
      },
      body: JSON.stringify(body)
    });
    if (!res.ok) {
      const txt = await res.text();
      throw new Error(`PUT failed: ${res.status} ${res.statusText} - ${txt}`);
    }
    return res.json();
  }

  async function ghDeleteContent(cfg, path, message, token, sha) {
    const url = `https://api.github.com/repos/${cfg.owner}/${cfg.repo}/contents/${path}`;
    const body = { message, sha };
    const res = await fetch(url, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json',
        ...(token ? { Authorization: `Bearer ${token}` } : {})
      },
      body: JSON.stringify(body)
    });
    if (!res.ok) {
      const txt = await res.text();
      throw new Error(`DELETE failed: ${res.status} ${res.statusText} - ${txt}`);
    }
    return res.json();
  }

  async function rawUpdateIndex(cfg, token, updater) {
    let indexData = await ghGetJSONRaw(cfg, cfg.indexPath);
    if (!indexData) indexData = { items: [] };
    const indexMeta = await ghGetContentMeta(cfg, cfg.indexPath, token);
    const sha = indexMeta?.sha;
    const newData = await updater(indexData);
    const enc = new TextEncoder().encode(JSON.stringify(newData, null, 2));
    const b64 = b64EncodeUint8(new Uint8Array(enc));
    await ghPutContent(cfg, cfg.indexPath, b64, `Update index.json`, token, sha);
    return true;
  }

  async function uploadCoverIfNeeded(cfg, token, file, existingPath) {
    if (!file) return existingPath || '';
    const buf = new Uint8Array(await file.arrayBuffer());
    const b64 = b64EncodeUint8(buf);
    const y = new Date().getFullYear();
    const m = String(new Date().getMonth()+1).padStart(2,'0');
    const baseDir = `${cfg.dataDir}/${y}/${m}`;
    const name = `cover_${Date.now()}_${file.name}`;
    const path = `${baseDir}/${name}`;
    const meta = await ghGetContentMeta(cfg, path, token);
    await ghPutContent(cfg, path, b64, `Upload cover ${file.name}`, token, meta?.sha);
    return path;
  }

  function uid() {
    return Math.random().toString(36).slice(2, 10) + Math.random().toString(36).slice(2, 10);
  }

  function fmtDate(ts) {
    if (!ts) return '';
    const d = new Date(ts);
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    const hh = String(d.getHours()).padStart(2,'0');
    const mm = String(d.getMinutes()).padStart(2,'0');
    return `${y}-${m}-${dd} ${hh}:${mm}`;
  }

  function loadConfig() {
    try {
      const s = localStorage.getItem('repoLibConfig');
      return s ? JSON.parse(s) : null;
    } catch(e) {
      console.error(e);
      return null;
    }
  }

  function saveConfig(cfg) {
    try {
      localStorage.setItem('repoLibConfig', JSON.stringify(cfg));
    } catch(e) {
      console.error(e);
    }
  }

  function loadToken() {
    try {
      return localStorage.getItem('repoLibToken') || '';
    } catch(e) {
      return '';
    }
  }

  function saveToken(token) {
    try {
      localStorage.setItem('repoLibToken', token || '');
    } catch(e) {
      console.error(e);
    }
  }

  const EXT_KIND = {
    'pdf': 'pdf',
    'md': 'text',
    'txt': 'text',
    'json': 'text',
    'csv': 'text',
    'py': 'code',
    'ipynb': 'code',
    'js': 'code',
    'ts': 'code',
    'tsx': 'code',
    'jsx': 'code',
    'c': 'code',
    'cpp': 'code',
    'h': 'code',
    'hpp': 'code',
    'f': 'code',
    'f90': 'code',
    'jl': 'code',
    'sh': 'code',
    'bat': 'code',
    'ps1': 'code',
    'mat': 'binary',
    'npy': 'binary',
    'npz': 'binary',
    'png': 'image',
    'jpg': 'image',
    'jpeg': 'image',
    'gif': 'image',
    'svg': 'image',
  };

  const FILE_KINDS = {
    pdf: {
      label: 'PDF æ–‡æ¡£',
      icon: (props) => <span {...props}>ğŸ“„</span>,
    },
    text: {
      label: 'æ–‡æœ¬/æ•°æ®',
      icon: (props) => <span {...props}>ğŸ“œ</span>,
    },
    code: {
      label: 'ä»£ç ',
      icon: (props) => <span {...props}>ğŸ’»</span>,
    },
    image: {
      label: 'å›¾ç‰‡',
      icon: (props) => <span {...props}>ğŸ–¼ï¸</span>,
    },
    binary: {
      label: 'äºŒè¿›åˆ¶æ•°æ®',
      icon: (props) => <span {...props}>ğŸ“¦</span>,
    },
    other: {
      label: 'å…¶ä»–',
      icon: (props) => <span {...props}>ğŸ“</span>,
    },
  };

  function extOf(name) {
    const m = name.toLowerCase().match(/\.([a-z0-9]+)$/);
    return m ? m[1] : '';
  }

  function guessKind(filename, override) {
    if (override) return override;
    const ext = extOf(filename);
    return EXT_KIND[ext] || 'other';
  }

  function guessHighlightLanguage(filename) {
    const ext = extOf(filename || '');
    switch (ext) {
      case 'py':
        return 'python';
      case 'js':
      case 'jsx':
      case 'ts':
      case 'tsx':
        return 'javascript';
      case 'c':
      case 'h':
      case 'cpp':
      case 'hpp':
        return 'cpp';
      case 'sh':
      case 'bat':
      case 'ps1':
        return 'bash';
      case 'json':
        return 'json';
      default:
        return '';
    }
  }

  function ConfigInput({ label, value, onChange, placeholder }) {
    return (
      <label className="text-xs text-slate-200 flex flex-col gap-1">
        <span>{label}</span>
        <input
          value={value}
          onChange={e=>onChange(e.target.value)}
          placeholder={placeholder}
          className="w-full px-3 py-1.5 rounded-lg bg-white/10 text-xs border border-white/20 focus:border-white/40 focus:outline-none focus:ring-1 focus:ring-amber-400"
        />
      </label>
    );
  }

  function ConfigPanel({ cfg, setCfg, token, setToken }) {
    const [localCfg, setLocalCfg] = useState(cfg);
    const [localToken, setLocalToken] = useState(token);
    return (
      <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mt-3 text-xs">
        <div className="space-y-2">
          <ConfigInput
            label="GitHub Owner"
            value={localCfg.owner}
            onChange={v=>setLocalCfg(c => ({...c, owner: v}))}
            placeholder="å¦‚ï¼šcheneit"
          />
          <ConfigInput
            label="GitHub Repo"
            value={localCfg.repo}
            onChange={v=>setLocalCfg(c => ({...c, repo: v}))}
            placeholder="å¦‚ï¼šcheneit.github.io"
          />
          <ConfigInput
            label="Branch"
            value={localCfg.branch}
            onChange={v=>setLocalCfg(c => ({...c, branch: v}))}
            placeholder="å¦‚ï¼šmain"
          />
        </div>
        <div className="space-y-2">
          <ConfigInput
            label="Data ç›®å½•ï¼ˆå­˜æ¡ç›®æ–‡ä»¶ï¼‰"
            value={localCfg.dataDir}
            onChange={v=>setLocalCfg(c => ({...c, dataDir: v}))}
            placeholder="å¦‚ï¼šdata/files"
          />
          <ConfigInput
            label="index.json è·¯å¾„"
            value={localCfg.indexPath}
            onChange={v=>setLocalCfg(c => ({...c, indexPath: v}))}
            placeholder="å¦‚ï¼šdata/index.json"
          />
          <label className="text-xs text-slate-200 flex flex-col gap-1">
            <span>GitHub PATï¼ˆä»…å†™å…¥ç”¨ï¼‰</span>
            <input
              type="password"
              value={localToken}
              onChange={e=>setLocalToken(e.target.value)}
              className="w-full px-3 py-1.5 rounded-lg bg-white/10 text-xs border border-white/20 focus:border-white/40 focus:outline-none focus:ring-1 focus:ring-amber-400"
              placeholder="æ¨èä½¿ç”¨åªè¯» / å•ä»“åº“ Token"
            />
          </label>
        </div>
        <div className="md:col-span-2 flex justify-end gap-2">
          <button
            onClick={() => { setCfg(localCfg); saveConfig(localCfg); setToken(localToken); saveToken(localToken); }}
            className="px-3 py-1.5 rounded-xl bg-amber-400 text-slate-900 text-xs"
          >
            ä¿å­˜é…ç½® & Token
          </button>
        </div>
      </div>
    );
  }

  function Header({ mode, setMode, query, setQuery, onSaveCfg, token, setToken, onHome, syncing }){
    const [showCfg, setShowCfg] = useState(false);

    return (
      <header className="bg-slate-900 text-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex flex-col gap-4">
          <div className="flex items-center justify-between gap-4">
            <div className="flex items-center gap-3">
              <div className="w-9 h-9 rounded-2xl bg-slate-800 flex items-center justify-center text-lg">ğŸ“š</div>
              <div>
                <div className="text-lg font-semibold">Repo Library</div>
                <div className="text-xs text-slate-300">GitHub é©±åŠ¨çš„ä¸€é¡µå¼æ–‡çŒ® / ä»£ç ç®¡ç†å·¥å…·</div>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <button
                onClick={onHome}
                className="px-3 py-1.5 rounded-xl bg-slate-800 hover:bg-slate-700 text-xs"
              >
                é‡ç½®æœç´¢
              </button>
              <button
                onClick={() => setMode('preview')}
                className={`px-3 py-1.5 rounded-xl text-xs ${mode==='preview' ? 'bg-white text-slate-900' : 'bg-slate-800 text-slate-200'}`}
              >
                é¢„è§ˆæ¨¡å¼
              </button>
              <button
                onClick={() => setMode('admin')}
                className={`px-3 py-1.5 rounded-xl text-xs ${mode==='admin' ? 'bg-amber-400 text-slate-900' : 'bg-slate-800 text-slate-200'}`}
              >
                ç®¡ç†æ¨¡å¼
              </button>
              <button
                onClick={() => setShowCfg(s => !s)}
                className="px-3 py-1.5 rounded-xl text-xs bg-slate-700 hover:bg-slate-600"
              >
                ä»“åº“è®¾ç½®
              </button>
              {syncing ? (
                <span className="ml-1 text-[11px] text-amber-300 whitespace-nowrap">
                  æ­£åœ¨åŒæ­¥åˆ° GitHubâ€¦
                </span>
              ) : null}
            </div>
          </div>

          <div className="flex flex-col md:flex-row gap-3">
            <div className="flex-1">
              <input
                value={query}
                onChange={(e)=>setQuery(e.target.value)}
                className="w-full px-3 py-2 rounded-xl bg-slate-800/80 border border-slate-700 text-sm focus:outline-none focus:ring-2 focus:ring-amber-400"
                placeholder="æœç´¢æ ‡é¢˜ / æ–‡ä»¶å / Topic / æ ‡ç­¾ / æè¿°..."
              />
            </div>
          </div>

          {showCfg ? (
            <ConfigPanel cfg={onSaveCfg ? undefined : {}} setCfg={onSaveCfg} token={token} setToken={setToken} />
          ) : null}
        </div>
      </header>
    );
  }

  function AdminPanelV2({ cfg, token, onUploaded, queueIndexUpdate, appendLog }){
    const [files, setFiles] = useState([]);
    const [title, setTitle] = useState('');
    const [topic, setTopic] = useState('');
    const [tags, setTags] = useState('');
    const [desc, setDesc] = useState('');
    const [cover, setCover] = useState(null);
    const [busy, setBusy] = useState(false);
    const [msg, setMsg] = useState('');

    function handleSelect(e){ setFiles(Array.from(e.target.files||[])); }
    function handleCover(e){ setCover((e.target.files||[])[0] || null); }

    async function uploadAll(){
      if (!token) { alert('è¯·å…ˆåœ¨ä¸Šæ–¹è®¾ç½®ç®¡ç†å‘˜ä»¤ç‰Œ (GitHub PAT)ã€‚'); return; }
      if (!files.length) { alert('è¯·é€‰æ‹©æ–‡ä»¶'); return; }
      setBusy(true); setMsg('');
      try {
        appendLog && appendLog(`å‡†å¤‡ä¸Šä¼  ${files.length} ä¸ªæ–‡ä»¶`, 'info');

        const y = new Date().getFullYear();
        const m = String(new Date().getMonth()+1).padStart(2,'0');
        const baseDir = `${cfg.dataDir}/${y}/${m}`;

        // ä¸Šä¼ å°é¢ï¼ˆå¦‚æœæœ‰ï¼‰
        const imagePath = await uploadCoverIfNeeded(cfg, token, cover, '');

        const newItems = [];
        let i = 0;

        for (const file of files) {
          i += 1;
          setMsg(`æ­£åœ¨ä¸Šä¼  (${i}/${files.length})ï¼š${file.name}`);

          const buf = new Uint8Array(await file.arrayBuffer());
          const base64 = b64EncodeUint8(buf);

          const id = uid();
          const cleanTitle = title || file.name.replace(/\.[^/.]+$/, '');
          const kind = guessKind(file.name);
          const ext = file.name.split('.').pop().toLowerCase();

          // å­˜åˆ°ä»“åº“é‡Œçš„çœŸå®æ–‡ä»¶åï¼š
          // - å¦‚æœæ˜¯ pdfï¼šåªç”¨éšæœºIDï¼Œå¦‚ q7n2kpux2rmhedzcjb.pdf
          // - å…¶ä»–ç±»å‹ï¼šç»§ç»­ä½¿ç”¨ éšæœºID__åŸæ–‡ä»¶å
          let storedFilename;
          if (kind === 'pdf' || ext === 'pdf') {
            storedFilename = `${id}.pdf`;
          } else {
            storedFilename = `${id}__${file.name}`;
          }

          const path = `${baseDir}/${storedFilename}`;

          const meta = await ghGetContentMeta(cfg, path, token);
          await ghPutContent(
            cfg,
            path,
            base64,
            `Upload ${file.name} via Repo Library`,
            token,
            meta?.sha
          );

          newItems.push({
            id,
            title: cleanTitle,
            filename: file.name,
            path,
            kind,
            topic: topic || '',
            tags: tags
              ? tags.split(',').map(s => s.trim()).filter(Boolean)
              : [],
            ts: Date.now(),
            size: file.size,
            desc: desc || '',
            imagePath: imagePath || '',
          });
        }

        if (queueIndexUpdate) {
          await queueIndexUpdate(`ä¸Šä¼  ${files.length} ä¸ªæ–‡ä»¶`, data => ({
            ...data,
            items: (data.items || []).concat(newItems),
          }));
        } else {
          // å…œåº•ï¼šå¦‚æœæ²¡ä¼  queueIndexUpdateï¼Œåˆ™ç›´æ¥æ›´æ–° index.json
          await rawUpdateIndex(cfg, token, data => ({
            ...data,
            items: (data.items || []).concat(newItems),
          }));
          onUploaded && onUploaded();
        }

        setMsg(`æˆåŠŸä¸Šä¼  ${files.length} ä¸ªæ–‡ä»¶ï¼Œå¹¶æ›´æ–°ç´¢å¼•ã€‚`);
        appendLog && appendLog(`æˆåŠŸä¸Šä¼  ${files.length} ä¸ªæ–‡ä»¶`, 'success');
        setFiles([]); setTitle(''); setTopic(''); setTags(''); setDesc(''); setCover(null);
      } catch(e) {
        console.error(e);
        setMsg('å‡ºé”™ï¼š' + e.message);
        appendLog && appendLog(`ä¸Šä¼ å¤±è´¥ï¼š${e.message}`, 'error');
      } finally { setBusy(false); }
    }

    const fileCount = files.length;
    const fileNames = fileCount ? files.map(f=>f.name).join(', ') : 'æœªé€‰æ‹©æ–‡ä»¶';

    return (
      <section className="mb-6">
        <div className="bg-white rounded-3xl shadow-soft border border-slate-200 p-4">
          <div className="flex items-center justify-between mb-3">
            <div className="font-semibold text-slate-900">ä¸Šä¼ æ–°æ¡ç›®</div>
            <div className="text-xs text-slate-500">æ–‡ä»¶ä¼šæŒ‰å¹´æœˆè‡ªåŠ¨å­˜å…¥ï¼š{cfg.dataDir}/YYYY/MM</div>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-3">
              <label className="text-sm block">
                <div className="mb-1 text-slate-700">é€‰æ‹©æ–‡ä»¶ (æ”¯æŒå¤šé€‰)</div>
                <input type="file" multiple onChange={handleSelect} className="block w-full text-sm" />
                <div className="mt-1 text-xs text-slate-500 truncate">å½“å‰: {fileNames}</div>
              </label>
              <label className="text-sm block">
                <div className="mb-1 text-slate-700">ç»Ÿä¸€æ ‡é¢˜ï¼ˆå¯é€‰ï¼Œç•™ç©ºåˆ™ç”¨æ–‡ä»¶åï¼‰</div>
                <input value={title} onChange={e=>setTitle(e.target.value)} className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm" />
              </label>
              <label className="text-sm block">
                <div className="mb-1 text-slate-700">Topicï¼ˆå¯é€‰ï¼‰</div>
                <input value={topic} onChange={e=>setTopic(e.target.value)} className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm" />
              </label>
            </div>
            <div className="space-y-3">
              <label className="text-sm block">
                <div className="mb-1 text-slate-700">æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼Œå¯é€‰ï¼‰</div>
                <input value={tags} onChange={e=>setTags(e.target.value)} className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm" />
              </label>
              <label className="text-sm block">
                <div className="mb-1 text-slate-700">æè¿°ï¼ˆå¯é€‰ï¼‰</div>
                <textarea value={desc} onChange={e=>setDesc(e.target.value)} rows={3} className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm" />
              </label>
              <label className="text-sm block">
                <div className="mb-1 text-slate-700">å°é¢å›¾ç‰‡ï¼ˆå¯é€‰ï¼‰</div>
                <input type="file" accept="image/*" onChange={handleCover} className="block w-full text-sm" />
              </label>
            </div>
          </div>
          <div className="mt-4 flex items-center gap-3">
            <button
              onClick={uploadAll}
              disabled={busy}
              className={`px-4 py-2 rounded-2xl text-sm text-white ${busy ? 'bg-slate-400' : 'bg-slate-900 hover:bg-slate-800'}`}
            >
              {busy ? 'ä¸Šä¼ ä¸­â€¦' : 'ä¸Šä¼ æ‰€æœ‰æ–‡ä»¶'}
            </button>
            {msg ? (
              <div className="text-xs text-slate-600">
                {msg}
              </div>
            ) : null}
          </div>
        </div>
      </section>
    );
  }

  function PreviewPanel({ loading, error, items, allTopics, allTags, activeTopic, setActiveTopic, activeTag, setActiveTag, sortBy, setSortBy, onOpen, cfg, mode, onEdit, onDeleted }){
    const total = items.length;

    function handleResetFilters(){
      setActiveTopic('');
      setActiveTag('');
      setSortBy('time_desc');
    }

    return (
      <section>
        <div className="flex flex-wrap items-center gap-3 mb-4">
          <select
            value={activeTopic}
            onChange={(e)=>setActiveTopic(e.target.value)}
            className="px-3 py-2 rounded-xl border border-slate-300 bg-white"
          >
            <option value="">å…¨éƒ¨ Topic</option>
            {allTopics.map(t => <option key={t} value={t}>{t}</option>)}
          </select>

          <select
            value={activeTag}
            onChange={(e)=>setActiveTag(e.target.value)}
            className="px-3 py-2 rounded-xl border border-slate-300 bg-white"
          >
            <option value="">å…¨éƒ¨æ ‡ç­¾</option>
            {allTags.map(t => <option key={t} value={t}>{t}</option>)}
          </select>

          <select
            value={sortBy}
            onChange={(e)=>setSortBy(e.target.value)}
            className="px-3 py-2 rounded-xl border border-slate-300 bg-white"
          >
            <option value="time_desc">æ—¶é—´ï¼šæœ€æ–°åœ¨å‰</option>
            <option value="time_asc">æ—¶é—´ï¼šæœ€æ—©åœ¨å‰</option>
            <option value="title_asc">æ ‡é¢˜ï¼šAâ†’Z</option>
            <option value="title_desc">æ ‡é¢˜ï¼šZâ†’A</option>
            <option value="type">ç±»å‹</option>
          </select>

          <button
            onClick={handleResetFilters}
            className="px-3 py-1.5 rounded-xl border border-slate-300 bg-slate-100 text-xs"
          >
            é‡ç½®ç­›é€‰
          </button>

          <div className="text-xs text-slate-500">
            å…± {total} æ¡
          </div>
        </div>

        {loading ? (
          <div className="text-sm text-slate-500">åŠ è½½ä¸­...</div>
        ) : error ? (
          <div className="text-sm text-rose-500">{error}</div>
        ) : (
          <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
            {items.map(item => (
              <CardV2
                key={item.id}
                cfg={cfg}
                item={item}
                onOpen={() => onOpen(item)}
                onEdit={() => onEdit(item)}
                onDelete={() => onDeleted && onDeleted(item)}
                canAdmin={mode==='admin'}
              />
            ))}
          </div>
        )}
      </section>
    );
  }

  function OperationLog({ logs }) {
    if (!logs || !logs.length) return null;
    return (
      <section className="mt-6">
        <div className="bg-white rounded-2xl border border-slate-200 p-3 text-xs max-h-40 overflow-auto">
          <div className="font-semibold text-slate-700 mb-2">æ“ä½œæ—¥å¿—</div>
          <ul className="space-y-1">
            {logs.slice().reverse().map(entry => (
              <li key={entry.id} className="flex justify-between gap-2">
                <span className={
                  entry.type === 'error'
                    ? 'text-rose-600'
                    : entry.type === 'success'
                    ? 'text-emerald-600'
                    : 'text-slate-700'
                }>
                  {entry.text}
                </span>
                <span className="text-[10px] text-slate-400">
                  {new Date(entry.ts).toLocaleTimeString()}
                </span>
              </li>
            ))}
          </ul>
        </div>
      </section>
    );
  }

  function CardV2({ cfg, item, onOpen, onEdit, onDelete, canAdmin }){
    const kindMeta = FILE_KINDS[item.kind] || FILE_KINDS.other;
    const Icon = kindMeta.icon;

    // rawHrefï¼šç»Ÿä¸€æŒ‡å‘ raw.githubusercontent.comï¼ˆæˆ–ä¿ç•™ç»å¯¹URLï¼‰ï¼Œç”¨äºä¸‹è½½ / åŸå§‹æŸ¥çœ‹
    const rawHref = buildRawUrl(cfg, item.path);

    // browserHrefï¼šç”¨äºâ€œåœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ / ç‚¹æ ‡é¢˜â€çš„é“¾æ¥
    // - PDFï¼šèµ° Pages ç«™ç‚¹è·¯å¾„ï¼ˆbuildPdfBrowserUrlï¼‰ï¼Œåœ¨æµè§ˆå™¨ç›´æ¥å±•ç¤º
    // - å…¶ä»–ç±»å‹ï¼šæ²¿ç”¨ rawHref
    const browserHref = item.kind === 'pdf'
      ? buildPdfBrowserUrl(item.path)
      : rawHref;

    const coverSrc = item.imagePath ? buildRawUrl(cfg, item.imagePath) : '';

    return (
      <div className="bgç™½ rounded-3xl border border-slate-200 shadow-soft p-4 flex flex-col h-full min-h-[340px]">
        <div className="mb-3 w-full h-36 rounded-2xl overflow-hidden bg-slate-100 flex items-center justify-center">
          {coverSrc ? (
            <img src={coverSrc} alt="cover" className="w-full h-full object-cover" />
          ) : (
            <div className="text-slate-400 text-sm">æ— å°é¢</div>
          )}
        </div>
        <div className="flex items-start gap-3">
          <div className="w-10 h-10 rounded-2xl flex items-center justify-center text-slate-700 bg-slate-50">
            <Icon className="w-6 h-6" />
          </div>
          <div className="flex-1 min-w-0">
            <div className="font-semibold text-slate-900 truncate">
              <a href={browserHref} target="_blank" rel="noreferrer" className="hover:underline">
                  {item.title || item.filename}
              </a>
            </div>
            <div className="text-xs text-slate-500 mt-0.5">
              {kindMeta.label} Â· {fmtDate(item.ts)}{item.topic ? ` Â· ${item.topic}` : ''}
            </div>
          </div>
        </div>
        {item.tags && item.tags.length ? (
          <div className="mt-3 flex flex-wrap gap-2">
            {item.tags.map(t => (
              <span key={t} className="text-xs px-2 py-1 rounded-full bg-slate-100 text-slate-700">
                #{t}
              </span>
            ))}
          </div>
        ) : null}
        {item.desc ? (
          <div className="mt-3 text-sm text-slate-700 max-h-20 overflow-hidden">
            {item.desc}
          </div>
        ) : null}
        <div className="mt-4 flex flex-wrap gap-2">
          {item.kind !== 'pdf' ? (
            <button onClick={onOpen} className="px-3 py-2 rounded-xl bg-slate-900 textç™½ hover:bg-slate-800 text-sm">
              é¢„è§ˆ
            </button>
          ) : null}
          <a href={rawHref} download className="px-3 py-2 rounded-xl bg-slate-100 hover:bg-slate-200 text-sm">
            ä¸‹è½½
          </a>
          <a href={browserHref} target="_blank" rel="noreferrer" className="px-3 py-2 rounded-xl bg-slate-200 hover:bg-slate-300 text-sm">
            åœ¨æµè§ˆå™¨æ‰“å¼€
          </a>
          {canAdmin ? (
            <>
              <button onClick={onEdit} className="px-3 py-2 rounded-xl bg-amber-100 text-amber-800 hover:bg-amber-200 text-sm">
                ç¼–è¾‘
              </button>
              <button onClick={onDelete} className="px-3 py-2 rounded-xl bg-rose-100 text-rose-800 hover:bg-rose-200 text-sm">
                åˆ é™¤
              </button>
            </>
          ) : null}
        </div>
      </div>
    );
  }

  function ViewerModal({ cfg, item, onClose }){
    const [text, setText] = useState('');
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState('');
    const lang = guessHighlightLanguage(item.filename);

    useEffect(() => {
      let cancelled = false;
      async function load(){
        setLoading(true); setError('');
        try {
          const t = await ghGetTextRaw(cfg, item.path);
          if (!cancelled) setText(t || '');
        } catch(e) {
          console.error(e);
          if (!cancelled) setError('æ— æ³•åŠ è½½æ–‡ä»¶å†…å®¹ï¼š' + e.message);
        } finally {
          if (!cancelled) setLoading(false);
        }
      }
      load();
      return () => { cancelled = true; };
    }, [cfg, item.path]);

    return (
      <div className="fixed inset-0 bg-black/40 flex items-center justify-center z-40">
        <div className="bg-white rounded-3xl shadow-soft max-w-4xl w-full max-h-[80vh] flex flex-col">
          <div className="px-4 py-3 border-b border-slate-200 flex items-center justify-between">
            <div className="font-semibold text-slate-900 truncate">{item.title || item.filename}</div>
            <button onClick={onClose} className="text-slate-500 hover:text-slate-800 text-sm">å…³é—­</button>
          </div>
          <div className="p-4 flex-1 overflow-auto">
            {loading ? (
              <div className="text-sm text-slate-500">åŠ è½½ä¸­...</div>
            ) : error ? (
              <div className="text-sm text-rose-500">{error}</div>
            ) : (
              <pre className="text-xs bg-slate-900 text-slate-100 rounded-2xl p-3 whitespace-pre-wrap">
                <code>{text}</code>
              </pre>
            )}
          </div>
        </div>
      </div>
    );
  }

  function EditItemModal({ cfg, item, onClose, onSave }){
    const [local, setLocal] = useState(() => ({
      ...item,
      title: item.title || '',
      topic: item.topic || '',
      desc: item.desc || '',
      tags: item.tags || [],
    }));
    const [newCover, setNewCover] = useState(null);

    function handleChange(field, value){
      setLocal(prev => ({ ...prev, [field]: value }));
    }

    function handleSubmit(){
      const tags = typeof local.tags === 'string'
        ? local.tags.split(',').map(s=>s.trim()).filter(Boolean)
        : local.tags;
      onSave({ ...local, tags });
    }

    return (
      <div className="fixed inset-0 bg-black/40 flex items-center justify-center z-50">
        <div className="bg-white rounded-3xl shadow-soft max-w-xl w-full max-h-[80vh] flex flex-col">
          <div className="px-4 py-3 border-b border-slate-200 flex items-center justify-between">
            <div className="font-semibold text-slate-900">ç¼–è¾‘æ¡ç›®</div>
            <button onClick={onClose} className="text-slate-500 hover:text-slate-800 text-sm">å…³é—­</button>
          </div>
          <div className="p-4 flex-1 overflow-auto space-y-3 text-sm">
            <label className="block">
              <div className="text-slate-700 mb-1">æ ‡é¢˜</div>
              <input
                value={local.title}
                onChange={e=>handleChange('title', e.target.value)}
                className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm"
              />
            </label>
            <label className="block">
              <div className="text-slate-700 mb-1">Topic</div>
              <input
                value={local.topic}
                onChange={e=>handleChange('topic', e.target.value)}
                className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm"
              />
            </label>
            <label className="block">
              <div className="text-slate-700 mb-1">æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼‰</div>
              <input
                value={Array.isArray(local.tags) ? local.tags.join(', ') : local.tags}
                onChange={e=>handleChange('tags', e.target.value)}
                className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm"
              />
            </label>
            <label className="block">
              <div className="text-slate-700 mb-1">æè¿°</div>
              <textarea
                value={local.desc}
                onChange={e=>handleChange('desc', e.target.value)}
                rows={3}
                className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm"
              />
            </label>
            <label className="block">
              <div className="text-slate-700 mb-1">æ›´æ¢å°é¢ï¼ˆå¯é€‰ï¼‰</div>
              <input
                type="file"
                accept="image/*"
                onChange={e=>setNewCover((e.target.files||[])[0] || null)}
                className="block w-full text-sm"
              />
            </label>
          </div>
          <div className="px-4 py-3 border-t border-slate-200 flex justify-end gap-2">
            <button
              onClick={onClose}
              className="px-4 py-2 rounded-xl bg-slate-100 text-slate-700 hover:bg-slate-200 text-sm"
            >
              å–æ¶ˆ
            </button>
            <button
              onClick={handleSubmit}
              className="px-4 py-2 rounded-xl bg-slate-900 textç™½ hover:bg-slate-800 text-sm"
            >
              ä¿å­˜
            </button>
          </div>
        </div>
      </div>
    );
  }

  function App(){
    const [cfg, setCfg] = useState(() => loadConfig() || {
      owner: 'cheneit',
      repo: 'cheneit.github.io',
      branch: 'main',
      dataDir: 'data/files',
      indexPath: 'data/index.json'
    });
    const [token, setToken] = useState(() => loadToken());
    const [mode, setMode] = useState('preview'); // 'preview' | 'admin'
    const [index, setIndex] = useState({ items: [] });
    const [loading, setLoading] = useState(false);
    const [syncing, setSyncing] = useState(false);
    const [logs, setLogs] = useState([]);
    const [error, setError] = useState('');
    const [query, setQuery] = useState('');
    const [activeTopic, setActiveTopic] = useState('');
    const [activeTag, setActiveTag] = useState('');
    const [sortBy, setSortBy] = useState('time_desc');
    const [selectedItem, setSelectedItem] = useState(null);
    const [editingItem, setEditingItem] = useState(null);

    const updateQueueRef = useRef(Promise.resolve());

    function appendLog(text, type = 'info') {
      setLogs(prev => {
        const entry = { id: uid(), ts: Date.now(), text, type };
        const next = [...prev, entry];
        return next.length > 50 ? next.slice(next.length - 50) : next;
      });
    }

    async function queueIndexUpdate(label, updater) {
      updateQueueRef.current = updateQueueRef.current.then(async () => {
        setSyncing(true);
        appendLog(`å¼€å§‹ï¼š${label}`, 'info');
        try {
          await rawUpdateIndex(cfg, token, updater);
          appendLog(`å®Œæˆï¼š${label}`, 'success');
          await refreshIndex();
        } catch (e) {
          console.error(e);
          appendLog(`å¤±è´¥ï¼š${label} - ${e.message}`, 'error');
        } finally {
          setSyncing(false);
        }
      });
      return updateQueueRef.current;
    }

    function onSaveCfg(newCfg){
      setCfg(newCfg);
      saveConfig(newCfg);
    }
    function onSaveToken(t){
      setToken(t);
      saveToken(t);
    }

    async function refreshIndex(){
      setLoading(true); setError('');
      try {
        const data = await ghGetJSONRaw(cfg, cfg.indexPath);
        setIndex(data || { items: [] });
      } catch(e) {
        console.error(e);
        setError('æ— æ³•åŠ è½½ index.jsonï¼š' + e.message);
      } finally {
        setLoading(false);
      }
    }

    useEffect(() => { refreshIndex(); }, [cfg.owner, cfg.repo, cfg.branch, cfg.dataDir, cfg.indexPath]);

    const allItems = index.items || [];
    const topics = useMemo(() => {
      const set = new Set();
      for (const item of allItems) {
        if (item.topic) set.add(item.topic);
      }
      return Array.from(set).sort();
    }, [allItems]);
    const allTags = useMemo(() => {
      const set = new Set();
      for (const item of allItems) {
        (item.tags || []).forEach(t => set.add(t));
      }
      return Array.from(set).sort();
    }, [allItems]);

    const filtered = useMemo(() => {
      const q = (query || '').trim().toLowerCase();
      let arr = allItems.slice();
      if (q) {
        arr = arr.filter(item => {
          const text = [
            item.title || '',
            item.filename || '',
            item.topic || '',
            item.desc || '',
            ...(item.tags || [])
          ].join(' ').toLowerCase();
          return text.includes(q);
        });
      }
      if (activeTopic) {
        arr = arr.filter(item => (item.topic || '') === activeTopic);
      }
      if (activeTag) {
        arr = arr.filter(item => (item.tags || []).includes(activeTag));
      }
      arr.sort((a,b) => {
        if (sortBy === 'time_desc') return (b.ts||0) - (a.ts||0);
        if (sortBy === 'time_asc') return (a.ts||0) - (b.ts||0);
        if (sortBy === 'title_asc') return (a.title||a.filename||'').localeCompare(b.title||b.filename||'');
        if (sortBy === 'title_desc') return (b.title||b.filename||'').localeCompare(a.title||a.filename||'');
        if (sortBy === 'type') return (a.kind||'').localeCompare(b.kind||'');
        return 0;
      });
      return arr;
    }, [allItems, query, activeTopic, activeTag, sortBy]);

    function goHome(){
      setQuery('');
      setActiveTopic('');
      setActiveTag('');
      setSortBy('time_desc');
    }

    async function handleDeleteItem(item){
      if (!token) return alert('éœ€è¦ç®¡ç†å‘˜ä»¤ç‰Œ');
      if (!confirm(`ç¡®è®¤åˆ é™¤ï¼š${item.title || item.filename} ?`)) return;
      try {
        appendLog(`è®¡åˆ’åˆ é™¤ï¼š${item.title || item.filename}`, 'info');
        const itemPath = item.path || '';
        if (itemPath && !isAbsoluteUrl(itemPath)) {
          const meta = await ghGetContentMeta(cfg, itemPath, token);
          if (meta?.sha) {
            await ghDeleteContent(cfg, itemPath, `Delete ${item.filename}`, token, meta.sha);
          }
        }
        if (item.imagePath && !isAbsoluteUrl(item.imagePath)) {
          try {
            const m2 = await ghGetContentMeta(cfg, item.imagePath, token);
            if (m2?.sha) {
              await ghDeleteContent(cfg, item.imagePath, `Delete cover for ${item.filename}`, token, m2.sha);
            }
          } catch(e) {
            console.warn('åˆ é™¤å°é¢å¤±è´¥', e);
          }
        }
        await queueIndexUpdate(`åˆ é™¤ ${item.title || item.filename}`, data => ({
          ...data,
          items: (data.items || []).filter(x => x.id !== item.id)
        }));
      } catch(e) {
        console.error(e);
        alert('åˆ é™¤å¤±è´¥ï¼š' + e.message);
      }
    }

    async function handleSaveEdit(updated, newCoverFile){
      if (!token) return alert('éœ€è¦ç®¡ç†å‘˜ä»¤ç‰Œ');
      try {
        const imagePath = await uploadCoverIfNeeded(cfg, token, newCoverFile, updated.imagePath || '');
        const newItem = { ...updated, imagePath };
        await queueIndexUpdate(`æ›´æ–° ${newItem.title || newItem.filename}`, data => ({
          ...data,
          items: (data.items || []).map(x => x.id === newItem.id ? newItem : x)
        }));
        setEditingItem(null);
      } catch(e) {
        console.error(e);
        alert('ä¿å­˜å¤±è´¥ï¼š' + e.message);
      }
    }

    return (
      <div className="min-h-full flex flex-col">
        <Header
          mode={mode}
          setMode={setMode}
          query={query}
          setQuery={setQuery}
          onSaveCfg={onSaveCfg}
          token={token}
          setToken={onSaveToken}
          onHome={goHome}
          syncing={syncing}
        />

        <main className="max-w-7xl w-full mx-auto px-4 sm:px-6 lg:px-8 py-6">
          {mode === 'admin' ? (
            <AdminPanelV2
              cfg={cfg}
              token={token}
              onUploaded={refreshIndex}
              queueIndexUpdate={queueIndexUpdate}
              appendLog={appendLog}
            />
          ) : null}

          <PreviewPanel
            loading={loading}
            error={error}
            items={filtered}
            allTopics={topics}
            allTags={allTags}
            activeTopic={activeTopic}
            setActiveTopic={setActiveTopic}
            activeTag={activeTag}
            setActiveTag={setActiveTag}
            sortBy={sortBy}
            setSortBy={setSortBy}
            onOpen={setSelectedItem}
            cfg={cfg}
            mode={mode}
            onEdit={setEditingItem}
            onDeleted={handleDeleteItem}
          />

          <OperationLog logs={logs} />
        </main>

        <Footer />

        {selectedItem ? (
          <ViewerModal cfg={cfg} item={selectedItem} onClose={() => setSelectedItem(null)} />
        ) : null}

        {editingItem ? (
          <EditItemModal cfg={cfg} item={editingItem} onClose={() => setEditingItem(null)} onSave={(item, cover)=>handleSaveEdit(item, cover)} />
        ) : null}
      </div>
    );
  }

  function AuthGate({ children }){
    const [checking, setChecking] = useState(true);
    const [authed, setAuthed] = useState(false);
    const [pw, setPw] = useState('');

    useEffect(() => {
      const stored = localStorage.getItem('repoLibPasswordOK');
      if (stored === '1') {
        setAuthed(true);
      }
      setChecking(false);
    }, []);

    function handleSubmit(e){
      e.preventDefault();
      const trimmed = (pw || '').trim();
      if (!trimmed) {
        alert('è¯·è¾“å…¥å¯†ç ');
        return;
      }
      // ç®€å•å¯†ç æ£€æŸ¥ï¼šè¿™é‡Œå†™æ­»ä¸€ä¸ªå¯†ç å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ "lib2025!"
      // ä½ å¯ä»¥æ”¹æˆæ›´å¤æ‚çš„é€»è¾‘ï¼Œæ¯”å¦‚ hash å¯¹æ¯”ç­‰
      const correct = '6543cc38c0864d19a15351545d60e99307b9cef4d9c2c21c225735744ea00762';
      if (trimmed === correct) {
        localStorage.setItem('repoLibPasswordOK', '1');
        setAuthed(true);
      } else {
        alert('å¯†ç é”™è¯¯');
      }
    }

    // åˆæ¬¡æ£€æŸ¥ localStorage æ—¶çš„è¿‡æ¸¡çŠ¶æ€
    if (checking) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-slate-900 text-slate-100">
          <div className="text-sm">åŠ è½½ä¸­...</div>
        </div>
      );
    }

    // æœªé€šè¿‡å¯†ç éªŒè¯æ—¶ï¼Œåªæ˜¾ç¤ºå¯†ç è¡¨å•
    if (!authed) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-slate-900 text-slate-50">
          <form
            onSubmit={handleSubmit}
            className="bg-slate-800 rounded-3xl p-6 w-full max-w-sm border border-slate-700 shadow-xl space-y-4"
          >
            <div className="text-lg font-semibold text-center">Private Repo Library</div>

            <label className="block text-sm">
              <span className="block mb-1 text-slate-200">è®¿é—®å¯†ç </span>
              <input
                type="password"
                value={pw}
                onChange={(e) => setPw(e.target.value)}
                className="w-full px-3 py-2 rounded-xl bg-slate-900/60 border border-slate-600 text-sm focus:outline-none focus:ring-2 focus:ring-amber-400"
                placeholder="è¯·è¾“å…¥å¯†ç "
              />
            </label>

            <button
              type="submit"
              className="w-full mt-2 px-3 py-2 rounded-xl bg-amber-400 text-slate-900 text-sm font-medium hover:bg-amber-300"
            >
              è¿›å…¥
            </button>
          </form>
        </div>
      );
    }

    // é€šè¿‡éªŒè¯åï¼Œæ­£å¸¸æ¸²æŸ“ App
    return children;
  }

  function Footer(){
    return (
      <footer className="border-t border-slate-200 mt-auto py-3 text-xs text-slate-500 text-center">
        <div>Â© {new Date().getFullYear()} Repo Library Â· GitHub æ‰˜ç®¡ Â· å•æ–‡ä»¶ç½‘é¡µ</div>
      </footer>
    );
  }

  ReactDOM.createRoot(document.getElementById('root')).render(
    <AuthGate>
      <App />
    </AuthGate>
  );
</script>

</body>
</html>
