
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Repo Library â€” Admin + Preview (PDF åˆ†ä»“ç‰ˆ)</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ["Inter", "ui-sans-serif", "system-ui", "-apple-system", "Segoe UI", "Roboto", "Noto Sans", "Ubuntu", "Cantarell", "Helvetica Neue", "Arial", "\"Apple Color Emoji\"", "\"Segoe UI Emoji\"", "\"Segoe UI Symbol\""]
          },
          boxShadow: { soft: "0 10px 30px rgba(0,0,0,0.08)" },
        },
      },
    };
  </script>

  <!-- React UMD + Babel (single-file JSX) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Fuse.js (optional; keep for future) -->
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>

  <!-- highlight.js for code/text display -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <style>
    html, body, #root { height: 100%; }
    .scrollbar-thin::-webkit-scrollbar { height: 8px; width: 8px; }
    .scrollbar-thin::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.18); border-radius: 999px; }

    /* Timeline (right sidebar) */
    .tl { position: relative; padding-left: 18px; }
    .tl:before { content: ""; position: absolute; left: 7px; top: 0; bottom: 0; width: 2px; background: rgba(15,23,42,0.15); border-radius: 999px; }
    .tl-dot { position: absolute; left: 1px; width: 14px; height: 14px; border-radius: 999px; background: #fb923c; border: 3px solid white; box-shadow: 0 6px 16px rgba(0,0,0,0.12); }
    .tl-dot.sm { width: 10px; height: 10px; left: 3px; background: #fbbf24; border-width: 2px; }
  </style>
</head>

<body class="bg-slate-50 text-slate-900">
  <div id="root" class="min-h-full"></div>

<script type="text/babel">
const { useState, useEffect, useMemo, useRef } = React;

/**
 * =========================
 * Repo Library â€” å•æ–‡ä»¶ SPA
 * - Previewï¼šæµè§ˆ / æœç´¢ / ç­›é€‰ / Dashboardï¼ˆç»Ÿè®¡ã€æ—¥å†ã€å½’æ¡£ï¼‰
 * - Adminï¼šä¸Šä¼  / ç¼–è¾‘ / åˆ é™¤ / æ›¿æ¢PDFï¼ˆæ³¨é‡Šåè¦†ç›–ï¼‰
 *
 * å…³é”®æ”¹åŠ¨ï¼š
 * 1) A æ–¹æ¡ˆï¼šPDF åˆ†ä»“ï¼ˆé»˜è®¤ prefix + å¹´ä»½ï¼Œä¾‹å¦‚ cheneit-pdf-2026ï¼‰
 * 2) æ–°ä¸Šä¼  PDFï¼šindex.json æ–°æ¡ç›®å¢åŠ  storage å­—æ®µï¼ˆæ—§æ¡ç›®ä¸æ”¹ç»“æ„ï¼‰
 * 3) é¦–é¡µä»…æ˜¾ç¤ºæœ€è¿‘ 6 æ¡ï¼Œå…¶ä½™æŠ˜å 
 * 4) Tags / Topics ç»Ÿè®¡ï¼ˆåœ†åœˆ badgeï¼‰ï¼Œè¯äº‘ + æ—¥å†çƒ­åŠ›å›¾
 * 5) å³ä¾§å½’æ¡£æ ï¼ˆæ—¶é—´è½´å¼ï¼‰ï¼Œé»˜è®¤å¼ºè°ƒæœ€è¿‘ 3 ç¯‡ + ä¸‹æ»‘æ›´å¤š
 * 6) æŒ‰é’®ç»Ÿä¸€ï¼šæµ…è‰²èƒŒæ™¯ + æ·±è‰²å­—ä½“ï¼Œä¸åŒåŠŸèƒ½ä¸åŒèƒŒæ™¯è‰²
 * =========================
 */

/* ============ ç®€å•å¯†ç ä¿æŠ¤ï¼ˆå¯é€‰ï¼‰ ============ */
const PASSWORD_HASH = '6543cc38c0864d19a15351545d60e99307b9cef4d9c2c21c225735744ea00762';
const AUTH_KEY = 'repoLibrary.authed';

async function sha256Hex(str) {
  const enc = new TextEncoder().encode(str);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
}

/* ============ UI helpers ============ */
function cx(...arr){ return arr.filter(Boolean).join(' '); }

function btnClass(variant='slate', extra='') {
  // ç»Ÿä¸€â€œæµ…è‰²èƒŒæ™¯ + æ·±è‰²å­—ä½“â€ï¼Œä¸åŒåŠŸèƒ½ç”¨ä¸åŒæµ…è‰²èƒŒæ™¯
  const base = "inline-flex items-center justify-center gap-2 px-3 py-2 rounded-xl text-sm font-medium border shadow-sm transition-colors";
  const map = {
    primary: "bg-sky-50 text-sky-800 border-sky-200 hover:bg-sky-100",
    success: "bg-emerald-50 text-emerald-800 border-emerald-200 hover:bg-emerald-100",
    warn:    "bg-amber-50 text-amber-900 border-amber-200 hover:bg-amber-100",
    danger:  "bg-rose-50 text-rose-800 border-rose-200 hover:bg-rose-100",
    slate:   "bg-white text-slate-800 border-slate-200 hover:bg-slate-50",
    subtle:  "bg-slate-50 text-slate-700 border-slate-200 hover:bg-slate-100",
    dark:    "bg-slate-900 text-white border-slate-900 hover:bg-slate-800",
  };
  return cx(base, map[variant] || map.slate, extra);
}

function badgeClass() {
  return "ml-2 inline-flex items-center justify-center min-w-[22px] h-[22px] px-1.5 rounded-full bg-rose-500 text-white text-xs font-semibold";
}

/* ============ Utilities ============ */
const fmtDate = (ts) => {
  try { return new Date(ts).toISOString().split('T')[0]; }
  catch { return ''; }
};
const uid = () => Math.random().toString(36).slice(2) + Date.now().toString(36);

const FILE_KINDS = {
  pdf:  { label: 'PDF',  pill: 'bg-red-100 text-red-700', icon: () => <span>ğŸ“„</span> },
  html: { label: 'HTML', pill: 'bg-orange-100 text-orange-700', icon: () => <span>ğŸŒ</span> },
  text: { label: 'TEXT', pill: 'bg-blue-100 text-blue-700', icon: () => <span>ğŸ“ƒ</span> },
  code: { label: 'CODE', pill: 'bg-emerald-100 text-emerald-700', icon: () => <span>ğŸ’»</span> },
  other:{ label: 'FILE', pill: 'bg-slate-100 text-slate-700', icon: () => <span>ğŸ“¦</span> },
};

const EXT_KIND = {
  pdf: 'pdf',
  html: 'html', htm: 'html',
  txt: 'text', md: 'text', rtf: 'text', log: 'text',
  py: 'code', js: 'code', jsx: 'code', ts: 'code', tsx: 'code', ipynb: 'code',
  sh: 'code', bash:'code', c: 'code', cpp: 'code', cu: 'code', f90:'code', f:'code',
  jl:'code', m:'code', rs:'code', tex:'code', css:'code', json:'code', yml:'code', yaml:'code'
};

function extOf(name) {
  const m = (name || '').toLowerCase().match(/\.([a-z0-9]+)$/);
  return m ? m[1] : '';
}

function guessKind(filename, override) {
  if (override) return override;
  const ext = extOf(filename);
  return EXT_KIND[ext] || 'other';
}

function guessHighlightLanguage(filename) {
  const ext = extOf(filename || '');
  switch (ext) {
    case 'py': return 'python';
    case 'js':
    case 'jsx': return 'javascript';
    case 'ts':
    case 'tsx': return 'typescript';
    case 'sh':
    case 'bash': return 'bash';
    case 'json': return 'json';
    case 'html':
    case 'htm': return 'xml';
    case 'css': return 'css';
    case 'c': return 'c';
    case 'cpp':
    case 'cc':
    case 'cxx':
    case 'h':
    case 'hpp': return 'cpp';
    case 'java': return 'java';
    case 'rb': return 'ruby';
    case 'go': return 'go';
    case 'rs': return 'rust';
    default: return '';
  }
}

function b64EncodeUint8(arr) {
  let binary = '';
  const len = arr.byteLength;
  for (let i = 0; i < len; i++) binary += String.fromCharCode(arr[i]);
  return btoa(binary);
}

/* ============ GitHub helpers (multi-repo) ============ */
function isAbsoluteUrl(path) { return /^https?:\/\//.test(path || ''); }

function ghRawUrl({ owner, repo, branch, path }) {
  return `https://raw.githubusercontent.com/${owner}/${repo}/${branch}/${path}`;
}

function buildRawUrl(cfg, path) {
  if (!path) return '#';
  if (isAbsoluteUrl(path)) return path;
  return ghRawUrl({ owner: cfg.owner, repo: cfg.repo, branch: cfg.branch, path });
}

/**
 * PDF åœ¨æµè§ˆå™¨æ‰“å¼€ï¼š
 * - æ–°æ¡ç›®ï¼šitem.path å¾€å¾€æ˜¯ Pages çš„ç»å¯¹ URLï¼ˆç›´æ¥ç”¨ï¼‰
 * - æ—§æ¡ç›®ï¼šç›¸å¯¹è·¯å¾„ï¼ˆdata/files/...ï¼‰ï¼Œè½¬ä¸ºç«™ç‚¹è·¯å¾„ /data/files/...
 * - ä¹Ÿå…¼å®¹ github.com/blob å’Œ raw.githubusercontent.com çš„è·¯å¾„æå–ï¼ˆä¿æŒä½ æ—§é€»è¾‘ï¼‰
 */
function buildPdfBrowserUrl(path) {
  if (!path) return '#';
  if (isAbsoluteUrl(path)) return path;

  try {
    const u = new URL(path);
    const host = u.hostname;
    const pathname = u.pathname;

    if (host === 'github.com') {
      const blobIndex = pathname.indexOf('/blob/');
      if (blobIndex !== -1) {
        const afterBlob = pathname.substring(blobIndex + '/blob/'.length);
        const firstSlash = afterBlob.indexOf('/');
        if (firstSlash !== -1) {
          const rest = afterBlob.substring(firstSlash + 1);
          return '/' + rest;
        }
      }
      return pathname;
    }

    if (host === 'raw.githubusercontent.com') {
      const parts = pathname.split('/').filter(Boolean);
      if (parts.length >= 4) {
        const rest = parts.slice(3).join('/');
        return '/' + rest;
      }
      return pathname;
    }

    return path;
  } catch {
    if (path.startsWith('/')) return path;
    return '/' + path;
  }
}

async function ghGetJSONRaw(owner, repo, branch, path) {
  const url = ghRawUrl({ owner, repo, branch, path });
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) return null;
  return await res.json();
}

async function ghGetTextRaw(owner, repo, branch, path) {
  const url = ghRawUrl({ owner, repo, branch, path });
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) return null;
  return await res.text();
}

async function ghGetContentMeta(owner, repo, path, token) {
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
  const res = await fetch(url, {
    headers: token ? { Authorization: `Bearer ${token}` } : {}
  });
  if (!res.ok) return null;
  return await res.json();
}

async function ghPutContent(owner, repo, path, contentB64, message, token, sha) {
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
  const body = { message, content: contentB64 };
  if (sha) body.sha = sha;

  const res = await fetch(url, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {})
    },
    body: JSON.stringify(body)
  });

  if (!res.ok) {
    const txt = await res.text();
    throw new Error(`PUT failed: ${res.status} ${res.statusText} - ${txt}`);
  }
  return res.json();
}

async function ghDeleteContent(owner, repo, path, message, token, sha) {
  const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;
  const body = { message, sha };

  const res = await fetch(url, {
    method: 'DELETE',
    headers: {
      'Content-Type': 'application/json',
      ...(token ? { Authorization: `Bearer ${token}` } : {})
    },
    body: JSON.stringify(body)
  });

  if (!res.ok) {
    const txt = await res.text();
    throw new Error(`DELETE failed: ${res.status} ${res.statusText} - ${txt}`);
  }
  return res.json();
}

/**
 * å°è¯•è‡ªåŠ¨åˆ›å»º repoï¼ˆå¦‚æœ token æƒé™å…è®¸ï¼‰
 * - å¯¹ fine-grained tokenï¼šé€šå¸¸ä¸ä¸€å®šå…è®¸åˆ›å»º repoï¼Œå› æ­¤å¤±è´¥æ—¶ç»™æç¤ºå³å¯
 */
async function ghTryCreateRepo(repoName, token, opts={}) {
  const payload = {
    name: repoName,
    description: opts.description || `PDF storage for Repo Library (${repoName})`,
    private: !!opts.private,
    has_issues: false,
    has_projects: false,
    has_wiki: false,
    auto_init: true
  };

  const res = await fetch("https://api.github.com/user/repos", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...(token ? { Authorization: `Bearer ${token}` } : {})
    },
    body: JSON.stringify(payload)
  });

  if (!res.ok) {
    const txt = await res.text();
    throw new Error(`Create repo failed: ${res.status} ${res.statusText} - ${txt}`);
  }
  return res.json();
}

/* ============ Index update (ä¸»ä»“åº“ index.json) ============ */
async function updateIndexMain(cfg, token, updater) {
  let indexData = await ghGetJSONRaw(cfg.owner, cfg.repo, cfg.branch, cfg.indexPath);
  if (!indexData) indexData = { items: [] };
  const meta = await ghGetContentMeta(cfg.owner, cfg.repo, cfg.indexPath, token);
  const sha = meta?.sha;

  const newData = await updater(indexData);
  const enc = new TextEncoder().encode(JSON.stringify(newData, null, 2));
  const b64 = b64EncodeUint8(new Uint8Array(enc));
  await ghPutContent(cfg.owner, cfg.repo, cfg.indexPath, b64, `Update index.json`, token, sha);
}

/* ============ Upload cover (ä»åœ¨ä¸»ä»“åº“) ============ */
async function uploadCoverIfNeeded(cfg, token, coverFile, existingPath) {
  if (!coverFile) return existingPath || '';
  const y = new Date().getFullYear();
  const m = String(new Date().getMonth() + 1).padStart(2, '0');
  const baseDir = `${cfg.dataDir}/${y}/${m}`;
  const buf = new Uint8Array(await coverFile.arrayBuffer());
  const b64 = b64EncodeUint8(buf);
  const imgName = `${uid()}__${coverFile.name}`;
  const imagePath = `${baseDir}/images/${imgName}`;

  const meta = await ghGetContentMeta(cfg.owner, cfg.repo, imagePath, token);
  await ghPutContent(cfg.owner, cfg.repo, imagePath, b64, `Upload cover ${coverFile.name}`, token, meta?.sha);
  return imagePath;
}

/* ============ Local Storage helpers ============ */
function loadConfig() {
  try {
    const raw = localStorage.getItem('repoLibrary.config');
    if (!raw) return null;
    return JSON.parse(raw);
  } catch (e) {
    console.error('loadConfig error', e);
    return null;
  }
}
function saveConfig(cfg) {
  try { localStorage.setItem('repoLibrary.config', JSON.stringify(cfg)); }
  catch (e) { console.error('saveConfig error', e); }
}
function loadToken() { return localStorage.getItem('repoLibrary.token') || ''; }
function saveToken(t) { if (!t) localStorage.removeItem('repoLibrary.token'); else localStorage.setItem('repoLibrary.token', t); }

/* ============ Dashboard computations ============ */
function getTopicsArr(item) {
  const arr = item?.topics || (item?.topic ? [item.topic] : []);
  return (arr || []).filter(Boolean);
}
function countBy(items, extractor) {
  const map = new Map();
  for (const it of items) {
    const keys = extractor(it) || [];
    for (const k of keys) {
      if (!k) continue;
      map.set(k, (map.get(k) || 0) + 1);
    }
  }
  return Array.from(map.entries()).sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]));
}

function buildHeatmap(items, days=365) {
  const now = new Date();
  const end = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const start = new Date(end);
  start.setDate(start.getDate() - (days-1));

  const dayKey = (d) => {
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const dd = String(d.getDate()).padStart(2,'0');
    return `${y}-${m}-${dd}`;
  };

  const counts = new Map();
  for (const it of items) {
    const d = new Date(it.ts || 0);
    if (isNaN(d)) continue;
    const dd = new Date(d.getFullYear(), d.getMonth(), d.getDate());
    if (dd < start || dd > end) continue;
    const k = dayKey(dd);
    counts.set(k, (counts.get(k)||0) + 1);
  }

  const daysArr = [];
  for (let d = new Date(start); d <= end; d.setDate(d.getDate()+1)) {
    const key = dayKey(d);
    daysArr.push({ date: new Date(d), key, count: counts.get(key) || 0 });
  }

  // Grid like GitHub (weeks columns, weekdays rows)
  // We align to Sunday at top (0) ... Saturday (6).
  const firstDow = daysArr[0].date.getDay();
  const padded = Array(firstDow).fill(null).concat(daysArr);

  const weeks = [];
  for (let i=0; i<padded.length; i+=7) weeks.push(padded.slice(i, i+7));

  // month labels: pick first day of month in data and its week index
  const monthMarks = [];
  let lastMonth = null;
  for (let w=0; w<weeks.length; w++) {
    for (let r=0; r<7; r++) {
      const cell = weeks[w][r];
      if (!cell) continue;
      const m = cell.date.getMonth();
      if (lastMonth === null) lastMonth = m;
      if (m !== lastMonth) {
        monthMarks.push({ week: w, month: m });
        lastMonth = m;
        break;
      }
      // first cell also can mark
      if (w === 0) {
        monthMarks.push({ week: 0, month: cell.date.getMonth() });
        break;
      }
      break;
    }
  }

  return { weeks, monthMarks };
}

function intensityClass(n) {
  if (!n) return "bg-slate-100 border-slate-200";
  if (n === 1) return "bg-emerald-100 border-emerald-200";
  if (n === 2) return "bg-emerald-200 border-emerald-300";
  if (n === 3) return "bg-emerald-300 border-emerald-400";
  return "bg-emerald-400 border-emerald-500";
}

/* ============ App ============ */
function App() {
  const [cfg, setCfg] = useState(() => loadConfig() || ({
    owner: 'cheneit',
    repo: 'cheneit.github.io',
    branch: 'main',
    dataDir: 'data/files',
    indexPath: 'data/index.json',
    // PDF åˆ†ä»“é…ç½®ï¼ˆæ–°å­—æ®µï¼›ä¸å½±å“æ—§ index.jsonï¼‰
    pdf: {
      enabled: true,
      repoPrefix: 'cheneit-pdf-',
      mode: 'yearly',              // yearly => prefix + YYYY
      manualRepo: '',              // å¯é€‰ï¼šè¦†ç›–é»˜è®¤ repo
      branch: 'main',
      dataDir: 'data/files',
      autoCreateRepo: true,        // Q2ï¼šé»˜è®¤å°è¯•è‡ªåŠ¨å»ºä»“ï¼ˆå¤±è´¥åˆ™æç¤ºæ‰‹åŠ¨å»ºä»“ï¼‰
      pagesBase: '',               // å¯é€‰ï¼šå¼ºåˆ¶ Pages baseï¼ˆç•™ç©ºåˆ™æŒ‰ owner.github.io/repo æ¨æ–­ï¼‰
      note: ''
    }
  }));
  const [token, setToken] = useState(() => loadToken());

  const [mode, setMode] = useState('preview'); // preview | admin

  const [index, setIndex] = useState({ items: [] });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const [query, setQuery] = useState('');
  const [activeTopic, setActiveTopic] = useState('');
  const [activeTag, setActiveTag] = useState('');
  const [sortBy, setSortBy] = useState('time_desc');

  const [selectedItem, setSelectedItem] = useState(null);
  const [editingItem, setEditingItem] = useState(null);
  const [replacingItem, setReplacingItem] = useState(null);

  const [showAllHome, setShowAllHome] = useState(false);

  function onSaveCfg(newCfg) { setCfg(newCfg); saveConfig(newCfg); }
  function onSaveToken(t) { setToken(t); saveToken(t); }

  async function refreshIndex() {
    setLoading(true); setError('');
    try {
      const data = await ghGetJSONRaw(cfg.owner, cfg.repo, cfg.branch, cfg.indexPath);
      setIndex(data || { items: [] });
    } catch (e) {
      console.error(e);
      setError('æ— æ³•åŠ è½½ index.jsonï¼š' + e.message);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    refreshIndex();
  }, [cfg.owner, cfg.repo, cfg.branch, cfg.dataDir, cfg.indexPath]);

  const allItems = index.items || [];

  const topicsCount = useMemo(() => countBy(allItems, it => getTopicsArr(it)), [allItems]);
  const tagsCount = useMemo(() => countBy(allItems, it => (it.tags || [])), [allItems]);

  const allTopics = useMemo(() => topicsCount.map(([k])=>k), [topicsCount]);
  const allTags = useMemo(() => tagsCount.map(([k])=>k), [tagsCount]);

  const filtered = useMemo(() => {
    const q = query.trim().toLowerCase();
    let arr = [...allItems];

    if (q) {
      arr = arr.filter(i => {
        const topicsArr = getTopicsArr(i);
        const text = [
          i.title, i.filename, topicsArr.join(' '),
          (i.tags||[]).join(' '), i.desc
        ].join(' ').toLowerCase();
        return text.includes(q);
      });
    }
    if (activeTopic) arr = arr.filter(i => getTopicsArr(i).includes(activeTopic));
    if (activeTag) arr = arr.filter(i => (i.tags||[]).includes(activeTag));

    arr.sort((a,b) => {
      if (sortBy === 'time_desc') return (b.ts||0) - (a.ts||0);
      if (sortBy === 'time_asc')  return (a.ts||0) - (b.ts||0);
      if (sortBy === 'title_asc') return (a.title||a.filename||'').localeCompare(b.title||b.filename||'');
      if (sortBy === 'title_desc')return (b.title||b.filename||'').localeCompare(a.title||a.filename||'');
      if (sortBy === 'type')      return (a.kind||'').localeCompare(b.kind||'');
      return 0;
    });

    return arr;
  }, [allItems, query, activeTopic, activeTag, sortBy]);

  const isHomeState = useMemo(() => {
    return !query.trim() && !activeTopic && !activeTag;
  }, [query, activeTopic, activeTag]);

  const displayItems = useMemo(() => {
    if (!isHomeState) return filtered;
    if (showAllHome) return filtered;
    return filtered.slice(0, 6);
  }, [filtered, isHomeState, showAllHome]);

  function goHome() {
    setQuery('');
    setActiveTopic('');
    setActiveTag('');
    setSortBy('time_desc');
    setShowAllHome(false);
  }

  async function handleDeleteItem(item) {
    if (!token) return alert('éœ€è¦ç®¡ç†å‘˜ä»¤ç‰Œ');
    if (!confirm(`ç¡®è®¤åˆ é™¤ï¼š${item.title || item.filename} ?`)) return;

    try {
      // 1) åˆ é™¤ä¸»æ–‡ä»¶ï¼ˆä¼˜å…ˆç”¨ storageï¼›å¦åˆ™ç”¨å½“å‰ä»“åº“ç›¸å¯¹è·¯å¾„ï¼‰
      const storage = item.storage;
      if (storage && storage.owner && storage.repo && storage.path) {
        const meta = await ghGetContentMeta(storage.owner, storage.repo, storage.path, token);
        if (meta?.sha) await ghDeleteContent(storage.owner, storage.repo, storage.path, `Delete ${item.filename}`, token, meta.sha);
      } else if (item.path && !isAbsoluteUrl(item.path)) {
        const meta = await ghGetContentMeta(cfg.owner, cfg.repo, item.path, token);
        if (meta?.sha) await ghDeleteContent(cfg.owner, cfg.repo, item.path, `Delete ${item.filename}`, token, meta.sha);
      }

      // 2) åˆ é™¤å°é¢ï¼ˆä»åœ¨ä¸»ä»“åº“ï¼‰
      if (item.imagePath && !isAbsoluteUrl(item.imagePath)) {
        try {
          const m2 = await ghGetContentMeta(cfg.owner, cfg.repo, item.imagePath, token);
          if (m2?.sha) await ghDeleteContent(cfg.owner, cfg.repo, item.imagePath, `Delete cover for ${item.filename}`, token, m2.sha);
        } catch(e) { console.warn('åˆ é™¤å°é¢å¤±è´¥', e); }
      }

      // 3) æ›´æ–° index.jsonï¼ˆä¸æ”¹æ—§ç»“æ„ï¼Œä»…åˆ é™¤è¯¥æ¡ï¼‰
      await updateIndexMain(cfg, token, data => ({
        ...data,
        items: (data.items || []).filter(x => x.id !== item.id)
      }));

      await refreshIndex();
    } catch (e) {
      alert('åˆ é™¤å¤±è´¥ï¼š' + e.message);
    }
  }

  async function handleSaveEdit(updated, newCoverFile) {
    if (!token) return alert('éœ€è¦ç®¡ç†å‘˜ä»¤ç‰Œ');
    try {
      const imagePath = await uploadCoverIfNeeded(cfg, token, newCoverFile, updated.imagePath || '');
      const newItem = { ...updated, imagePath };

      await updateIndexMain(cfg, token, data => ({
        ...data,
        items: (data.items || []).map(x => x.id === newItem.id ? newItem : x)
      }));

      setEditingItem(null);
      await refreshIndex();
    } catch (e) {
      alert('ä¿å­˜å¤±è´¥ï¼š' + e.message);
    }
  }

  async function handleReplacePdf(item, newFile) {
    if (!token) return alert('éœ€è¦ç®¡ç†å‘˜ä»¤ç‰Œ');
    if (!newFile) return;

    try {
      const buf = new Uint8Array(await newFile.arrayBuffer());
      const b64 = b64EncodeUint8(buf);

      // æ›¿æ¢ç›®æ ‡ï¼šä¼˜å…ˆ storageï¼ˆæ–°æ¡ç›®ï¼‰ï¼›å¦åˆ™æ—§æ¡ç›®ç›¸å¯¹è·¯å¾„ï¼ˆä¸»ä»“åº“ï¼‰
      let targetOwner = cfg.owner;
      let targetRepo = cfg.repo;
      let targetPath = item.path;

      if (item.storage?.owner && item.storage?.repo && item.storage?.path) {
        targetOwner = item.storage.owner;
        targetRepo = item.storage.repo;
        targetPath = item.storage.path;
      } else {
        if (isAbsoluteUrl(item.path)) {
          throw new Error("è¯¥æ¡ç›®æ²¡æœ‰ storage ä¿¡æ¯ä¸” path æ˜¯ç»å¯¹ URLï¼Œæ— æ³•ç¡®å®šä»“åº“ä½ç½®ã€‚å»ºè®®ï¼šå¯¹æ–°ä¸Šä¼  PDF ä½¿ç”¨åˆ†ä»“æ¨¡å¼ï¼ˆä¼šè‡ªåŠ¨å†™å…¥ storageï¼‰ï¼Œæˆ–æ‰‹åŠ¨è¡¥ storage å­—æ®µã€‚");
        }
        if (!targetPath) throw new Error("ç¼ºå°‘ pathï¼Œæ— æ³•æ›¿æ¢ã€‚");
      }

      const meta = await ghGetContentMeta(targetOwner, targetRepo, targetPath, token);
      await ghPutContent(targetOwner, targetRepo, targetPath, b64, `Replace PDF ${item.filename}`, token, meta?.sha);

      // åªæ›´æ–°è¯¥æ¡ç›®çš„ size / ts / filenameï¼ˆä¸æ”¹å˜æ—§ç»“æ„ï¼›å¦‚æœæ—§æ¡ç›®æ²¡æœ‰ storage ä¹Ÿä¸æ–°å¢ï¼‰
      await updateIndexMain(cfg, token, data => ({
        ...data,
        items: (data.items || []).map(x => {
          if (x.id !== item.id) return x;
          return {
            ...x,
            filename: newFile.name || x.filename,
            size: newFile.size,
            ts: Date.now()
          };
        })
      }));

      setReplacingItem(null);
      await refreshIndex();
      alert("æ›¿æ¢æˆåŠŸï¼ˆé“¾æ¥ä¿æŒä¸å˜ï¼‰ã€‚");
    } catch (e) {
      alert("æ›¿æ¢å¤±è´¥ï¼š" + e.message);
    }
  }

  return (
    <div className="min-h-full flex flex-col">
      <Header
        mode={mode}
        setMode={setMode}
        query={query}
        setQuery={setQuery}
        onSaveCfg={onSaveCfg}
        token={token}
        setToken={onSaveToken}
        onHome={goHome}
        cfg={cfg}
      />

      <main className="max-w-7xl w-full mx-auto px-4 sm:px-6 lg:px-8 py-6">
        {mode === 'admin' ? (
          <AdminPanel
            cfg={cfg}
            token={token}
            onUploaded={() => { refreshIndex(); }}
          />
        ) : null}

        <div className={cx("grid gap-6", "lg:grid-cols-[1fr_360px]")}>
          <div className="space-y-6">
            {/* Dashboard åªåœ¨é¦–é¡µæ€å±•ç¤º */}
            {isHomeState ? (
              <Dashboard
                items={filtered}
                topicsCount={topicsCount}
                tagsCount={tagsCount}
                onPickTopic={(t)=>{ setActiveTopic(t); setShowAllHome(true); }}
                onPickTag={(t)=>{ setActiveTag(t); setShowAllHome(true); }}
              />
            ) : null}

            <PreviewPanel
              loading={loading}
              error={error}
              items={displayItems}
              totalAll={filtered.length}
              allTopics={allTopics}
              allTags={allTags}
              activeTopic={activeTopic}
              setActiveTopic={(t)=>{ setActiveTopic(t); setShowAllHome(true); }}
              activeTag={activeTag}
              setActiveTag={(t)=>{ setActiveTag(t); setShowAllHome(true); }}
              sortBy={sortBy}
              setSortBy={setSortBy}
              onOpen={setSelectedItem}
              cfg={cfg}
              mode={mode}
              onEdit={setEditingItem}
              onDeleted={handleDeleteItem}
              showFold={isHomeState}
              showAllHome={showAllHome}
              setShowAllHome={setShowAllHome}
            />
          </div>

          <div className="lg:sticky lg:top-6 h-fit">
            <ArchiveSidebar
              items={filtered}
              onOpen={(it)=>setSelectedItem(it)}
            />
          </div>
        </div>
      </main>

      <Footer />

      {selectedItem ? (
        <ViewerModal cfg={cfg} item={selectedItem} onClose={() => setSelectedItem(null)} onReplace={() => setReplacingItem(selectedItem)} mode={mode} />
      ) : null}

      {editingItem ? (
        <EditItemModal item={editingItem} onClose={() => setEditingItem(null)} onSave={handleSaveEdit} />
      ) : null}

      {replacingItem ? (
        <ReplacePdfModal
          item={replacingItem}
          onClose={() => setReplacingItem(null)}
          onReplace={(file)=>handleReplacePdf(replacingItem, file)}
        />
      ) : null}
    </div>
  );
}

/* ============ Header / Config ============ */
function Header({ mode, setMode, query, setQuery, onSaveCfg, token, setToken, onHome, cfg }) {
  const [showCfg, setShowCfg] = useState(false);

  return (
    <header className="bg-slate-900 text-white">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex flex-col gap-4">
        <div className="flex items-center justify-between gap-4">
          <div className="flex items-center gap-3">
            <div className="w-9 h-9 rounded-2xl bg-slate-800 flex items-center justify-center text-lg">ğŸ“š</div>
            <div>
              <div className="text-lg font-semibold">Repo Library</div>
              <div className="text-xs text-slate-300">PDF åˆ†ä»“ + å½’æ¡£ä»ªè¡¨ç›˜ï¼ˆå•é¡µç‰ˆï¼‰</div>
            </div>
          </div>
          <div className="flex items-center gap-2 flex-wrap justify-end">
            <button onClick={onHome} className={btnClass('subtle', 'bg-slate-800 text-white border-slate-700 hover:bg-slate-700')}>
              é‡ç½®æœç´¢
            </button>
            <button
              onClick={() => setMode('preview')}
              className={btnClass('subtle', mode==='preview' ? 'bg-white text-slate-900 border-white' : 'bg-slate-800 text-slate-200 border-slate-700 hover:bg-slate-700')}
            >
              é¢„è§ˆæ¨¡å¼
            </button>
            <button
              onClick={() => setMode('admin')}
              className={btnClass('warn', mode==='admin' ? 'bg-amber-200 border-amber-200 text-amber-950' : 'bg-slate-800 text-slate-200 border-slate-700 hover:bg-slate-700')}
              title="éœ€è¦ PAT æ‰èƒ½ä¸Šä¼ ã€åˆ é™¤ã€æ›¿æ¢"
            >
              ç®¡ç†æ¨¡å¼
            </button>
            <button onClick={() => setShowCfg(s => !s)} className={btnClass('subtle', 'bg-slate-800 text-white border-slate-700 hover:bg-slate-700')}>
              ä»“åº“è®¾ç½®
            </button>
          </div>
        </div>

        <div className="flex flex-col md:flex-row gap-3">
          <div className="flex-1">
            <input
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              className="w-full px-3 py-2 rounded-xl bg-slate-800 border border-slate-700 placeholder-slate-400 text-sm focus:outline-none focus:ring-2 focus:ring-amber-400"
              placeholder="æœç´¢æ ‡é¢˜ / æ–‡ä»¶å / Topic / æ ‡ç­¾ / æè¿°..."
            />
          </div>
        </div>

        {showCfg ? (
          <div className="mt-2 border border-slate-700 rounded-2xl p-3">
            <ConfigPanel cfg={cfg} setCfg={onSaveCfg} token={token} setToken={setToken} />
          </div>
        ) : null}
      </div>
    </header>
  );
}

function LabeledInput({ label, value, onChange, placeholder }) {
  return (
    <label className="text-sm">
      <div className="mb-1 text-white/80">{label}</div>
      <input
        value={value}
        onChange={e => onChange(e.target.value)}
        placeholder={placeholder}
        className="w-full px-3 py-2 rounded-lg bg-white/10 border border-white/20 text-xs placeholder-white/40 focus:outline-none focus:ring-1 focus:ring-amber-400"
      />
    </label>
  );
}

function LabeledToggle({ label, checked, onChange, hint }) {
  return (
    <div className="flex items-start gap-3">
      <input type="checkbox" className="mt-1" checked={checked} onChange={e=>onChange(e.target.checked)} />
      <div>
        <div className="text-sm text-white/90">{label}</div>
        {hint ? <div className="text-xs text-white/60 mt-0.5">{hint}</div> : null}
      </div>
    </div>
  );
}

function ConfigPanel({ cfg, setCfg, token, setToken }) {
  const [localCfg, setLocalCfg] = useState(cfg);
  const [localToken, setLocalToken] = useState(token);

  const pdf = localCfg.pdf || {};
  const setPdf = (patch) => setLocalCfg({ ...localCfg, pdf: { ...(localCfg.pdf || {}), ...patch } });

  return (
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
      <div className="bg-white/5 rounded-2xl p-4 border border-white/10">
        <div className="font-semibold mb-3">ä¸»ä»“åº“è®¾ç½®ï¼ˆindex.json æ‰€åœ¨ä»“åº“ï¼‰</div>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
          <LabeledInput label="Owner" value={localCfg.owner} onChange={v => setLocalCfg({ ...localCfg, owner: v })} />
          <LabeledInput label="Repo" value={localCfg.repo} onChange={v => setLocalCfg({ ...localCfg, repo: v })} />
          <LabeledInput label="Branch" value={localCfg.branch} onChange={v => setLocalCfg({ ...localCfg, branch: v })} />
          <LabeledInput label="æ•°æ®ç›®å½• (files)" value={localCfg.dataDir} onChange={v => setLocalCfg({ ...localCfg, dataDir: v })} />
          <LabeledInput label="ç´¢å¼•æ–‡ä»¶è·¯å¾„" value={localCfg.indexPath} onChange={v => setLocalCfg({ ...localCfg, indexPath: v })} />
        </div>
        <div className="mt-3 flex gap-2 flex-wrap">
          <button onClick={() => setCfg(localCfg)} className={btnClass('success', 'text-sm')}>
            ä¿å­˜é…ç½®
          </button>
          <a className={btnClass('slate', 'text-sm')} target="_blank" rel="noreferrer"
             href={`https://github.com/${localCfg.owner}/${localCfg.repo}`}>
            æ‰“å¼€ä¸»ä»“åº“
          </a>
        </div>
      </div>

      <div className="bg-white/5 rounded-2xl p-4 border border-white/10">
        <div className="font-semibold mb-3">PDF åˆ†ä»“è®¾ç½®ï¼ˆA æ–¹æ¡ˆï¼‰</div>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
          <LabeledInput label="ä»“åº“å‰ç¼€ (repoPrefix)" value={pdf.repoPrefix || ''} onChange={v => setPdf({ repoPrefix: v })} placeholder="cheneit-pdf-" />
          <LabeledInput label="PDF åˆ†ä»“åˆ†æ”¯" value={pdf.branch || ''} onChange={v => setPdf({ branch: v })} placeholder="main" />
          <LabeledInput label="PDF æ•°æ®ç›®å½•" value={pdf.dataDir || ''} onChange={v => setPdf({ dataDir: v })} placeholder="data/files" />
          <LabeledInput label="æ‰‹åŠ¨è¦†ç›–ä»“åº“åï¼ˆå¯ç©ºï¼‰" value={pdf.manualRepo || ''} onChange={v => setPdf({ manualRepo: v })} placeholder="è‹¥å¡«åˆ™ä¸æŒ‰å¹´ä»½" />
          <LabeledInput label="Pages Baseï¼ˆå¯ç©ºï¼‰" value={pdf.pagesBase || ''} onChange={v => setPdf({ pagesBase: v })} placeholder="https://owner.github.io/repo" />
          <LabeledInput label="å¤‡æ³¨ï¼ˆå¯ç©ºï¼‰" value={pdf.note || ''} onChange={v => setPdf({ note: v })} placeholder="æ¯”å¦‚ï¼šé¦–æ¬¡éœ€åœ¨è¯¥ repo Settings->Pages å¼€å¯éƒ¨ç½²" />
        </div>

        <div className="mt-3 space-y-2">
          <LabeledToggle
            label="å¯ç”¨ PDF åˆ†ä»“ï¼ˆæ–°ä¸Šä¼  PDF å°†è¿›å…¥ç‹¬ç«‹ä»“åº“ï¼‰"
            checked={pdf.enabled !== false}
            onChange={(v)=>setPdf({ enabled: v })}
          />
          <LabeledToggle
            label="å°è¯•è‡ªåŠ¨åˆ›å»º PDF ä»“åº“ï¼ˆè‹¥ token æƒé™å…è®¸ï¼‰"
            checked={!!pdf.autoCreateRepo}
            onChange={(v)=>setPdf({ autoCreateRepo: v })}
            hint="è‹¥å¤±è´¥ï¼šè¯·æ‰‹åŠ¨åˆ›å»ºå¯¹åº”ä»“åº“å¹¶å¼€å¯ Pagesï¼›ä¹‹åä»å¯ç»§ç»­ä½¿ç”¨ï¼ˆä¼šè‡ªåŠ¨å†™å…¥ storageï¼‰ã€‚"
          />
        </div>

        <div className="mt-3 flex gap-2 flex-wrap">
          <button onClick={() => setCfg(localCfg)} className={btnClass('success', 'text-sm')}>ä¿å­˜é…ç½®</button>
          <a className={btnClass('slate', 'text-sm')} target="_blank" rel="noreferrer"
             href={`https://github.com/${localCfg.owner}`}>
            æ‰“å¼€ GitHub ä¸»é¡µ
          </a>
        </div>
      </div>

      <div className="bg-white/5 rounded-2xl p-4 border border-white/10 lg:col-span-2">
        <div className="font-semibold mb-3">ç®¡ç†å‘˜ä»¤ç‰Œ (Personal Access Token)</div>
        <p className="text-sm text-white/70 mb-2">
          å»ºè®®ä½¿ç”¨ç»†ç²’åº¦ä»¤ç‰Œï¼šå¯¹ <b>ä¸»ä»“åº“</b> æˆäºˆ Contents: Read &amp; Writeï¼›å¯¹ <b>PDF åˆ†ä»“ä»“åº“</b> åŒæ ·æˆäºˆã€‚
          è‹¥ä½ å¸Œæœ›â€œè‡ªåŠ¨åˆ›å»ºä»“åº“â€ï¼Œtoken è¿˜éœ€è¦å…è®¸åˆ›å»ºä»“åº“ï¼ˆé€šå¸¸éœ€è¦æ›´é«˜æƒé™/Classic tokenï¼‰ã€‚
          ä»¤ç‰Œåªä¿å­˜åœ¨æœ¬æœºæµè§ˆå™¨ LocalStorageã€‚
        </p>
        <input
          type="password"
          className="w-full px-3 py-2 rounded-lg bg-white/10 text-sm placeholder-white/60 border border-white/20 focus:outline-none"
          placeholder="github_pat_xxx æˆ– ghp_xxx"
          value={localToken}
          onChange={(e) => setLocalToken(e.target.value)}
        />
        <div className="mt-3 flex gap-2 flex-wrap">
          <button onClick={() => setToken(localToken)} className={btnClass('warn', 'text-sm')}>ä¿å­˜ä»¤ç‰Œ</button>
          <button onClick={() => { setLocalToken(''); setToken(''); }} className={btnClass('slate', 'text-sm')}>æ¸…é™¤ä»¤ç‰Œ</button>
        </div>
      </div>
    </div>
  );
}

/* ============ Admin Panel ============ */
function AdminPanel({ cfg, token, onUploaded }) {
  const [files, setFiles] = useState([]);
  const [title, setTitle] = useState('');
  const [topicsInput, setTopicsInput] = useState('');
  const [tags, setTags] = useState('');
  const [desc, setDesc] = useState('');
  const [cover, setCover] = useState(null);

  const [busy, setBusy] = useState(false);
  const [msg, setMsg] = useState('');

  function handleSelect(e) { setFiles(Array.from(e.target.files || [])); }
  function handleCover(e) { setCover((e.target.files || [])[0] || null); }

  function resolvePdfRepoName(year) {
    const pdf = cfg.pdf || {};
    if (pdf.manualRepo && pdf.manualRepo.trim()) return pdf.manualRepo.trim();
    const prefix = pdf.repoPrefix || 'cheneit-pdf-';
    return `${prefix}${year}`;
  }

  function resolvePagesBase(owner, repo) {
    const pdf = cfg.pdf || {};
    // å¦‚æœè®¾ç½®äº† pagesBaseï¼šç›´æ¥ç”¨ï¼ˆå¯èƒ½æƒ³æ”¾åœ¨è‡ªå®šä¹‰åŸŸåä¸‹ï¼‰
    if (pdf.pagesBase && pdf.pagesBase.trim()) {
      return pdf.pagesBase.replace(/\/+$/,'');
    }
    // é»˜è®¤ Pages baseï¼šhttps://owner.github.io/repo
    return `https://${owner}.github.io/${repo}`;
  }

  async function uploadAll() {
    if (!token) { alert('è¯·å…ˆåœ¨ä¸Šæ–¹è®¾ç½®ç®¡ç†å‘˜ä»¤ç‰Œ (GitHub PAT)ã€‚'); return; }
    if (!files.length) { alert('è¯·é€‰æ‹©æ–‡ä»¶'); return; }

    setBusy(true);
    setMsg('');

    try {
      let indexData = await ghGetJSONRaw(cfg.owner, cfg.repo, cfg.branch, cfg.indexPath);
      if (!indexData) indexData = { items: [] };

      const indexMeta = await ghGetContentMeta(cfg.owner, cfg.repo, cfg.indexPath, token);
      const indexSha = indexMeta?.sha;

      // å°é¢ä»ä¸Šä¼ åˆ°ä¸»ä»“åº“ï¼ˆä¾¿äºç»Ÿä¸€å±•ç¤ºï¼‰
      const imagePath = await uploadCoverIfNeeded(cfg, token, cover, '');

      const now = new Date();
      const y = now.getFullYear();
      const m = String(now.getMonth() + 1).padStart(2, '0');

      const baseDirMain = `${cfg.dataDir}/${y}/${m}`;
      const pdfCfg = cfg.pdf || {};
      const pdfEnabled = pdfCfg.enabled !== false;

      // è‹¥æœ¬æ¬¡æ‰¹æ¬¡åŒ…å« PDFï¼Œå…ˆå‡†å¤‡ pdf repoï¼ˆå°è¯•è‡ªåŠ¨åˆ›å»º + åˆå§‹åŒ–ï¼‰
      let ensuredPdfRepo = false;
      let pdfRepoName = null;

      const topicsArr = topicsInput ? topicsInput.split(',').map(s => s.trim()).filter(Boolean) : [];
      const tagsArr = tags ? tags.split(',').map(s => s.trim()).filter(Boolean) : [];

      let i = 0;

      for (const file of files) {
        i += 1;
        setMsg(`æ­£åœ¨ä¸Šä¼  (${i}/${files.length})ï¼š${file.name}`);

        const id = uid();
        const cleanTitle = title || file.name.replace(/\.[^/.]+$/, '');
        const kind = guessKind(file.name);
        const ext = extOf(file.name);

        const isPdf = (kind === 'pdf' || ext === 'pdf');

        // è¯»å–æ–‡ä»¶ base64
        const buf = new Uint8Array(await file.arrayBuffer());
        const base64 = b64EncodeUint8(buf);

        // æ–‡ä»¶åç­–ç•¥ï¼šPDF ä½¿ç”¨éšæœºID.pdfï¼›å…¶ä»–ä¿æŒ éšæœºID__åŸæ–‡ä»¶å
        let storedFilename;
        if (isPdf) storedFilename = `${id}.pdf`;
        else storedFilename = `${id}__${file.name}`;

        if (isPdf && pdfEnabled) {
          // ========== PDF åˆ†ä»“ ==========
          const pdfYear = y; // ç›®å‰æŒ‰ä¸Šä¼ å¹´ä»½
          pdfRepoName = resolvePdfRepoName(pdfYear);

          // å°è¯•è‡ªåŠ¨åˆ›å»ºä»“åº“ï¼ˆä»…ç¬¬ä¸€æ¬¡ï¼‰
          if (!ensuredPdfRepo) {
            ensuredPdfRepo = true;

            // ç¡®è®¤ repo æ˜¯å¦å­˜åœ¨ï¼ˆè®¿é—®ä¸€æ¬¡ contents/ï¼‰
            try {
              const test = await fetch(`https://api.github.com/repos/${cfg.owner}/${pdfRepoName}`, {
                headers: token ? { Authorization: `Bearer ${token}` } : {}
              });
              if (test.status === 404) {
                if (pdfCfg.autoCreateRepo) {
                  setMsg(`æ£€æµ‹åˆ° PDF ä»“åº“ä¸å­˜åœ¨ï¼Œå°è¯•è‡ªåŠ¨åˆ›å»ºï¼š${pdfRepoName} ...`);
                  try {
                    await ghTryCreateRepo(pdfRepoName, token, { private: false });
                    // å†™ä¸€ä¸ª .nojekyll + READMEï¼ˆæœ‰åŠ©äº Pagesï¼‰
                    const nojekyllMeta = await ghGetContentMeta(cfg.owner, pdfRepoName, '.nojekyll', token);
                    await ghPutContent(cfg.owner, pdfRepoName, '.nojekyll', b64EncodeUint8(new Uint8Array([])), 'Add .nojekyll', token, nojekyllMeta?.sha);

                    const readme = new TextEncoder().encode(`# ${pdfRepoName}\n\nThis repo is used by Repo Library to store PDFs.\n\n- Enable GitHub Pages: Settings -> Pages -> Deploy from branch -> main / root\n`);
                    const readmeB64 = b64EncodeUint8(new Uint8Array(readme));
                    const readmeMeta = await ghGetContentMeta(cfg.owner, pdfRepoName, 'README.md', token);
                    await ghPutContent(cfg.owner, pdfRepoName, 'README.md', readmeB64, 'Init README for Pages', token, readmeMeta?.sha);

                    setMsg(`PDF ä»“åº“å·²åˆ›å»ºï¼š${pdfRepoName}ã€‚æ³¨æ„ï¼šé¦–æ¬¡éœ€è¦åœ¨è¯¥ä»“åº“ Settings -> Pages å¼€å¯éƒ¨ç½²ã€‚`);
                  } catch (e) {
                    throw new Error(
                      `è‡ªåŠ¨åˆ›å»º PDF ä»“åº“å¤±è´¥ã€‚è¯·æ‰‹åŠ¨åˆ›å»ºä»“åº“ "${pdfRepoName}" å¹¶å¼€å¯ Pagesï¼Œç„¶åé‡è¯•ä¸Šä¼ ã€‚\n\nåŸå§‹é”™è¯¯ï¼š${e.message}`
                    );
                  }
                } else {
                  throw new Error(`PDF ä»“åº“ä¸å­˜åœ¨ï¼š${pdfRepoName}ã€‚è¯·å…ˆæ‰‹åŠ¨åˆ›å»ºå¹¶å¼€å¯ Pagesã€‚`);
                }
              }
            } catch (e) {
              // è‹¥æ˜¯ç½‘ç»œç­‰é”™è¯¯ï¼Œä¹ŸæŠ›å‡º
              if (String(e.message || '').includes('è‡ªåŠ¨åˆ›å»º PDF ä»“åº“å¤±è´¥')) throw e;
              // å¿½ç•¥é 404 çš„çŠ¶æ€æ£€æŸ¥é—®é¢˜ï¼ˆä¾‹å¦‚æƒé™ä¸è¶³çœ‹ä¸åˆ°ä»“åº“ä¿¡æ¯ï¼‰ï¼Œç»§ç»­å°è¯•ä¸Šä¼ ï¼ˆè‹¥å¤±è´¥ä¼šç»™å‡ºæ›´æ˜ç¡®é”™è¯¯ï¼‰
            }
          }

          const pdfDataDir = pdfCfg.dataDir || 'data/files';
          const baseDirPdf = `${pdfDataDir}/${pdfYear}/${m}`;
          const pathInPdfRepo = `${baseDirPdf}/${storedFilename}`;

          // ä¸Šä¼ åˆ° PDF ä»“åº“
          const meta = await ghGetContentMeta(cfg.owner, pdfRepoName, pathInPdfRepo, token);
          await ghPutContent(cfg.owner, pdfRepoName, pathInPdfRepo, base64, `Upload ${file.name} via Repo Library (PDF storage)`, token, meta?.sha);

          // Pages è®¿é—® URLï¼ˆç”¨äºæµè§ˆå™¨ç›´æ¥æ‰“å¼€ï¼‰
          const pagesBase = resolvePagesBase(cfg.owner, pdfRepoName);
          const pagesUrl = `${pagesBase}/${pathInPdfRepo}`;

          // å†™å…¥ index.jsonï¼šæ—§æ¡ç›®ç»“æ„ä¸åŠ¨ï¼›æ–°æ¡ç›®å¢åŠ  storage å­—æ®µï¼ˆä»…æ–°æ¡ç›®ï¼‰
          indexData.items.push({
            id,
            title: cleanTitle,
            filename: file.name,
            // æ–°ï¼špath å­˜ Pages ç»å¯¹ URLï¼ˆä½ è¦â€œç‚¹å¼€å°±èƒ½åœ¨æµè§ˆå™¨ç›´æ¥çœ‹ PDFâ€ï¼‰
            path: pagesUrl,
            kind: 'pdf',
            topics: topicsArr,
            topic: topicsArr[0] || '',
            tags: tagsArr,
            ts: Date.now(),
            size: file.size,
            desc: desc || '',
            imagePath: imagePath || '',
            // æ–°ï¼šstorage è®°å½•çœŸå®ä½ç½®ï¼Œä¾¿äºåˆ é™¤/æ›¿æ¢
            storage: {
              owner: cfg.owner,
              repo: pdfRepoName,
              branch: pdfCfg.branch || 'main',
              path: pathInPdfRepo
            }
          });

        } else {
          // ========== é PDFï¼šä»åœ¨ä¸»ä»“åº“ ==========
          const pathInMain = `${baseDirMain}/${storedFilename}`;
          const meta = await ghGetContentMeta(cfg.owner, cfg.repo, pathInMain, token);
          await ghPutContent(cfg.owner, cfg.repo, pathInMain, base64, `Upload ${file.name} via Repo Library`, token, meta?.sha);

          indexData.items.push({
            id,
            title: cleanTitle,
            filename: file.name,
            path: pathInMain,
            kind,
            topics: topicsArr,
            topic: topicsArr[0] || '',
            tags: tagsArr,
            ts: Date.now(),
            size: file.size,
            desc: desc || '',
            imagePath: imagePath || '',
          });
        }
      }

      // å†™å› index.jsonï¼ˆä»åœ¨ä¸»ä»“åº“ï¼‰
      const updated = new TextEncoder().encode(JSON.stringify(indexData, null, 2));
      const updatedB64 = b64EncodeUint8(new Uint8Array(updated));
      await ghPutContent(cfg.owner, cfg.repo, cfg.indexPath, updatedB64, `Update index.json (${files.length} items)`, token, indexSha);

      setMsg(`æˆåŠŸä¸Šä¼  ${files.length} ä¸ªæ–‡ä»¶ï¼Œå¹¶æ›´æ–°ç´¢å¼•ã€‚`);
      setFiles([]); setTitle(''); setTopicsInput(''); setTags(''); setDesc(''); setCover(null);
      onUploaded && onUploaded();

    } catch (e) {
      console.error(e);
      setMsg('å‡ºé”™ï¼š' + e.message);
    } finally {
      setBusy(false);
    }
  }

  const fileCount = files.length;
  const fileNames = fileCount ? files.map(f => f.name).join(', ') : 'æœªé€‰æ‹©æ–‡ä»¶';

  const pdfRepoHint = (() => {
    const y = new Date().getFullYear();
    const pdfRepoName = (cfg.pdf?.manualRepo && cfg.pdf.manualRepo.trim())
      ? cfg.pdf.manualRepo.trim()
      : `${cfg.pdf?.repoPrefix || 'cheneit-pdf-'}${y}`;
    return pdfRepoName;
  })();

  return (
    <section className="mb-6">
      <div className="bg-white rounded-3xl shadow-soft border border-slate-200 p-4">
        <div className="flex items-center justify-between mb-3 gap-3 flex-wrap">
          <div className="font-semibold text-slate-900">ä¸Šä¼ æ–°æ¡ç›®</div>
          <div className="text-xs text-slate-500">
            é PDF è‡ªåŠ¨å­˜å…¥ï¼š{cfg.dataDir}/YYYY/MMï¼›PDF é»˜è®¤åˆ†ä»“ï¼š<b>{pdfRepoHint}</b>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-3">
            <label className="text-sm block">
              <div className="mb-1 text-slate-700">é€‰æ‹©æ–‡ä»¶ (æ”¯æŒå¤šé€‰)</div>
              <input type="file" multiple onChange={handleSelect} className="block w-full text-sm" />
              <div className="mt-1 text-xs text-slate-500 truncate">å½“å‰: {fileNames}</div>
            </label>

            <label className="text-sm block">
              <div className="mb-1 text-slate-700">ç»Ÿä¸€æ ‡é¢˜ï¼ˆå¯é€‰ï¼Œç•™ç©ºåˆ™ç”¨æ–‡ä»¶åï¼‰</div>
              <input value={title} onChange={e => setTitle(e.target.value)} className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm bg-white" />
            </label>

            <label className="text-sm block">
              <div className="mb-1 text-slate-700">Topicsï¼ˆé€—å·åˆ†éš”ï¼Œå¤š topicï¼‰</div>
              <input value={topicsInput} onChange={e => setTopicsInput(e.target.value)} className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm bg-white" />
            </label>

            <label className="text-sm block">
              <div className="mb-1 text-slate-700">æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼‰</div>
              <input value={tags} onChange={e => setTags(e.target.value)} className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm bg-white" />
            </label>
          </div>

          <div className="space-y-3">
            <label className="text-sm block">
              <div className="mb-1 text-slate-700">æ¡ç›®ç®€è¦æè¿°</div>
              <textarea value={desc} onChange={e => setDesc(e.target.value)} rows={5} className="w-full px-3 py-2 rounded-xl border border-slate-300 text-sm bg-white" />
            </label>

            <label className="text-sm block">
              <div className="mb-1 text-slate-700">å°é¢å›¾ï¼ˆå¯é€‰ï¼Œå»ºè®® 16:9 æˆ– 4:3ï¼‰</div>
              <input type="file" accept="image/*" onChange={handleCover} className="block w-full text-sm" />
            </label>

            <div className="rounded-2xl border border-slate-200 bg-slate-50 p-3 text-xs text-slate-600">
              <div className="font-semibold text-slate-700 mb-1">æç¤º</div>
              <ul className="list-disc pl-5 space-y-1">
                <li>æ–°ä¸Šä¼  PDFï¼šä¼šå†™å…¥ <code>storage</code> å­—æ®µï¼Œæ–¹ä¾¿â€œæ›¿æ¢ PDF/åˆ é™¤â€ã€‚æ—§æ¡ç›®ä¸æ”¹åŠ¨ã€‚</li>
                <li>è‹¥è‡ªåŠ¨å»ºä»“æˆåŠŸï¼šè¯·åˆ°è¯¥ PDF ä»“åº“çš„ <b>Settings â†’ Pages</b> å¼€å¯éƒ¨ç½²ï¼ˆé¦–æ¬¡ä¸€æ¬¡å³å¯ï¼‰ã€‚</li>
                <li>å¦‚æœä½ æƒ³æŠŠ PDF é›†ä¸­è¿›å›ºå®šä»“åº“ï¼šåœ¨ã€Œä»“åº“è®¾ç½® â†’ PDF åˆ†ä»“ã€å¡« <b>æ‰‹åŠ¨è¦†ç›–ä»“åº“å</b>ã€‚</li>
              </ul>
            </div>
          </div>
        </div>

        <div className="mt-4 flex items-center gap-3 flex-wrap">
          <button
            onClick={uploadAll}
            disabled={busy}
            className={btnClass('primary', busy ? 'opacity-60 cursor-not-allowed' : '')}
          >
            {busy ? 'ä¸Šä¼ ä¸­â€¦' : 'ä¸Šä¼ æ‰€æœ‰æ–‡ä»¶'}
          </button>
          {msg ? <div className="text-sm text-slate-600">{msg}</div> : null}
        </div>
      </div>
    </section>
  );
}

/* ============ Dashboard ============ */
function Dashboard({ items, topicsCount, tagsCount, onPickTopic, onPickTag }) {
  const heat = useMemo(() => buildHeatmap(items, 365), [items]);

  // è¯äº‘ï¼šå– topics å‰ 10
  const topTopics = topicsCount.slice(0, 10);
  const maxCnt = topTopics.length ? topTopics[0][1] : 1;

  return (
    <section className="space-y-6">
      <div className="bg-white rounded-3xl shadow-soft border border-slate-200 p-4">
        <div className="flex items-center gap-2 text-slate-900 font-semibold mb-3">
          <span className="text-lg">ğŸ·ï¸</span>
          <span>æ–‡ç« æ ‡ç­¾ / ä¸»é¢˜</span>
        </div>

        {/* Topics row */}
        <div className="flex flex-wrap gap-2 mb-3">
          {topicsCount.slice(0, 12).map(([t, c]) => (
            <button key={t} onClick={()=>onPickTopic(t)} className={btnClass('success', 'px-3 py-2')}>
              {t}<span className={badgeClass()}>{c}</span>
            </button>
          ))}
          {topicsCount.length > 12 ? (
            <span className="text-xs text-slate-500 self-center ml-1">ï¼ˆæ›´å¤šè¯·ç”¨ç­›é€‰/æœç´¢ï¼‰</span>
          ) : null}
        </div>

        {/* Tags row */}
        <div className="flex flex-wrap gap-2">
          {tagsCount.slice(0, 12).map(([t, c]) => (
            <button key={t} onClick={()=>onPickTag(t)} className={btnClass('slate', 'px-3 py-2')}>
              {t}<span className={badgeClass()}>{c}</span>
            </button>
          ))}
          {tagsCount.length > 12 ? (
            <span className="text-xs text-slate-500 self-center ml-1">ï¼ˆæ›´å¤šè¯·ç”¨ç­›é€‰/æœç´¢ï¼‰</span>
          ) : null}
        </div>

        {/* Word cloud */}
        <div className="mt-5">
          <div className="text-sm font-semibold text-slate-700 mb-2">çƒ­ç‚¹ Topicï¼ˆè¯äº‘ï¼‰</div>
          <div className="bg-slate-50 border border-slate-200 rounded-2xl p-4 overflow-hidden">
            <div className="flex flex-wrap gap-x-4 gap-y-2 items-end">
              {topTopics.map(([t,c]) => {
                const scale = 0.9 + (c / maxCnt) * 1.3; // 0.9 - 2.2
                return (
                  <button
                    key={t}
                    onClick={()=>onPickTopic(t)}
                    className="text-sky-700 hover:text-sky-900"
                    style={{ fontSize: `${Math.round(12 * scale)}px`, lineHeight: 1.1 }}
                    title={`${t}: ${c}`}
                  >
                    {t}
                  </button>
                );
              })}
            </div>
          </div>
        </div>
      </div>

      {/* Heatmap */}
      <div className="bg-white rounded-3xl shadow-soft border border-slate-200 p-4">
        <div className="flex items-center gap-2 text-slate-900 font-semibold mb-3">
          <span className="text-lg">ğŸ—“ï¸</span>
          <span>æ–‡ç« æ—¥å†</span>
          <span className="ml-auto text-xs text-slate-500">æœ€è¿‘ 1 å¹´ä¸Šä¼ å¯†åº¦</span>
        </div>

        <Heatmap heat={heat} />
      </div>
    </section>
  );
}

function Heatmap({ heat }) {
  const monthNames = ["ä¸€æœˆ","äºŒæœˆ","ä¸‰æœˆ","å››æœˆ","äº”æœˆ","å…­æœˆ","ä¸ƒæœˆ","å…«æœˆ","ä¹æœˆ","åæœˆ","åä¸€æœˆ","åäºŒæœˆ"];
  // Month marks are not perfect but good enough
  return (
    <div className="overflow-auto scrollbar-thin">
      <div className="min-w-[720px]">
        {/* Month labels */}
        <div className="flex text-xs text-slate-500 mb-2 pl-10">
          {(() => {
            const marks = new Array(heat.weeks.length).fill('');
            heat.monthMarks.forEach(m => { marks[m.week] = monthNames[m.month]; });
            return marks.map((txt, idx) => (
              <div key={idx} className="w-4" style={{ width: 14 }}>
                {txt ? <span className="whitespace-nowrap">{txt}</span> : null}
              </div>
            ));
          })()}
        </div>

        <div className="flex gap-1">
          {/* Weekday labels */}
          <div className="w-9 flex flex-col gap-1 text-xs text-slate-500 pr-1 pt-1">
            <div className="h-3"></div>
            <div className="h-3"></div>
            <div className="h-3">äºŒ</div>
            <div className="h-3"></div>
            <div className="h-3">å››</div>
            <div className="h-3"></div>
            <div className="h-3">å…­</div>
          </div>

          {heat.weeks.map((week, wi) => (
            <div key={wi} className="flex flex-col gap-1">
              {week.map((cell, ri) => {
                if (!cell) return <div key={ri} className="w-3.5 h-3.5" />;
                const title = `${cell.key}ï¼š${cell.count}`;
                return (
                  <div
                    key={ri}
                    title={title}
                    className={cx("w-3.5 h-3.5 rounded-sm border", intensityClass(cell.count))}
                  />
                );
              })}
            </div>
          ))}
        </div>

        <div className="flex items-center gap-2 mt-3 text-xs text-slate-500">
          <span>å°‘</span>
          <div className="w-3.5 h-3.5 rounded-sm border bg-slate-100 border-slate-200"></div>
          <div className="w-3.5 h-3.5 rounded-sm border bg-emerald-100 border-emerald-200"></div>
          <div className="w-3.5 h-3.5 rounded-sm border bg-emerald-200 border-emerald-300"></div>
          <div className="w-3.5 h-3.5 rounded-sm border bg-emerald-300 border-emerald-400"></div>
          <div className="w-3.5 h-3.5 rounded-sm border bg-emerald-400 border-emerald-500"></div>
          <span>å¤š</span>
        </div>
      </div>
    </div>
  );
}

/* ============ Preview Panel ============ */
function PreviewPanel({
  loading, error, items, totalAll,
  allTopics, allTags,
  activeTopic, setActiveTopic,
  activeTag, setActiveTag,
  sortBy, setSortBy,
  onOpen, cfg, mode,
  onEdit, onDeleted,
  showFold, showAllHome, setShowAllHome
}) {
  function handleResetFilters() {
    setActiveTopic('');
    setActiveTag('');
    setSortBy('time_desc');
    setShowAllHome(false);
  }

  return (
    <section className="bg-white rounded-3xl shadow-soft border border-slate-200 p-4">
      <div className="flex flex-wrap items-center gap-3 mb-4">
        <select value={activeTopic} onChange={(e) => setActiveTopic(e.target.value)} className="px-3 py-2 rounded-xl border border-slate-300 bg-white text-sm">
          <option value="">å…¨éƒ¨ Topic</option>
          {allTopics.map(t => <option key={t} value={t}>{t}</option>)}
        </select>

        <select value={activeTag} onChange={(e) => setActiveTag(e.target.value)} className="px-3 py-2 rounded-xl border border-slate-300 bg-white text-sm">
          <option value="">å…¨éƒ¨æ ‡ç­¾</option>
          {allTags.map(t => <option key={t} value={t}>{t}</option>)}
        </select>

        <select value={sortBy} onChange={(e) => setSortBy(e.target.value)} className="px-3 py-2 rounded-xl border border-slate-300 bg-white text-sm">
          <option value="time_desc">æŒ‰æ—¶é—´(æ–°â†’æ—§)</option>
          <option value="time_asc">æŒ‰æ—¶é—´(æ—§â†’æ–°)</option>
          <option value="title_asc">æ ‡é¢˜(Aâ†’Z)</option>
          <option value="title_desc">æ ‡é¢˜(Zâ†’A)</option>
          <option value="type">æŒ‰ç±»å‹</option>
        </select>

        <button type="button" onClick={handleResetFilters} className={btnClass('slate')}>
          é‡ç½®ç­›é€‰
        </button>

        <span className="ml-auto text-sm text-slate-500">
          æ˜¾ç¤º {items.length} / å…± {totalAll} æ¡
        </span>
      </div>

      {loading ? <div className="text-slate-600">åŠ è½½ä¸­â€¦</div> : null}
      {error ? <div className="text-rose-600">{error}</div> : null}

      <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-5">
        {items.map(item => (
          <Card
            key={item.id}
            cfg={cfg}
            item={item}
            canAdmin={mode === 'admin'}
            onOpen={() => onOpen(item)}
            onEdit={() => onEdit && onEdit(item)}
            onDelete={() => onDeleted && onDeleted(item)}
          />
        ))}
      </div>

      {/* é¦–é¡µæŠ˜å æŒ‰é’® */}
      {showFold && totalAll > 6 ? (
        <div className="mt-5 flex justify-center">
          <button
            onClick={() => setShowAllHome(!showAllHome)}
            className={btnClass('subtle')}
          >
            {showAllHome ? 'æŠ˜å ï¼ˆåªçœ‹æœ€è¿‘6æ¡ï¼‰' : `å±•å¼€æ›´å¤šï¼ˆè¿˜æœ‰ ${totalAll - 6} æ¡ï¼‰`}
          </button>
        </div>
      ) : null}

      {!loading && !totalAll ? (
        <div className="text-sm text-slate-500 mt-6">æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„æ¡ç›®ã€‚</div>
      ) : null}
    </section>
  );
}

/* ============ Card ============ */
function Card({ cfg, item, onOpen, onEdit, onDelete, canAdmin }) {
  const kindMeta = FILE_KINDS[item.kind] || FILE_KINDS.other;
  const Icon = kindMeta.icon;

  const topicsArr = getTopicsArr(item);

  // rawï¼šä¼˜å…ˆç”¨ storageï¼ˆæ–°æ¡ç›®ï¼‰ä»¥ä¾¿èƒ½ä¸‹è½½çœŸå®æ–‡ä»¶ï¼›å¦åˆ™æ²¿ç”¨æ—§é€»è¾‘
  const rawHref = (() => {
    if (item.storage?.owner && item.storage?.repo && item.storage?.path) {
      const branch = item.storage.branch || (cfg.pdf?.branch || 'main');
      return ghRawUrl({ owner: item.storage.owner, repo: item.storage.repo, branch, path: item.storage.path });
    }
    return buildRawUrl(cfg, item.path);
  })();

  // æµè§ˆå™¨æ‰“å¼€ï¼šPDF => Pages URLï¼ˆæ–°æ¡ç›® path=ç»å¯¹URLï¼›æ—§æ¡ç›®èµ° /data/files/...ï¼‰
  const browserHref = (item.kind === 'pdf')
    ? buildPdfBrowserUrl(item.path)
    : rawHref;

  const coverSrc = item.imagePath ? buildRawUrl(cfg, item.imagePath) : '';

  return (
    <div className="bg-white rounded-3xl border border-slate-200 shadow-soft p-4 flex flex-col h-full min-h-[340px]">
      <div className="mb-3 w-full h-36 rounded-2xl overflow-hidden bg-slate-100 flex items-center justify-center">
        {coverSrc ? (
          <img src={coverSrc} alt="cover" className="w-full h-full object-cover" />
        ) : (
          <div className="text-slate-400 text-sm">æ— å°é¢</div>
        )}
      </div>

      <div className="flex items-start gap-3">
        <div className="w-10 h-10 rounded-2xl flex items-center justify-center text-slate-700 bg-slate-50 border border-slate-200">
          <Icon />
        </div>

        <div className="flex-1 min-w-0">
          <div className="font-semibold text-slate-900 truncate">
            <a href={browserHref} target="_blank" rel="noreferrer" className="hover:underline">
              {item.title || item.filename}
            </a>
          </div>
          <div className="text-xs text-slate-500 mt-0.5">
            {kindMeta.label} Â· {fmtDate(item.ts)}{topicsArr[0] ? ` Â· ${topicsArr[0]}` : ''}
          </div>
        </div>
      </div>

      {topicsArr.length ? (
        <div className="mt-3 flex flex-wrap gap-2">
          {topicsArr.map(t => (
            <span key={t} className="text-xs px-2 py-1 rounded-full bg-emerald-50 text-emerald-800 border border-emerald-200">
              {t}
            </span>
          ))}
        </div>
      ) : null}

      {item.tags && item.tags.length ? (
        <div className="mt-3 flex flex-wrap gap-2">
          {item.tags.map(t => (
            <span key={t} className="text-xs px-2 py-1 rounded-full bg-slate-50 text-slate-700 border border-slate-200">
              #{t}
            </span>
          ))}
        </div>
      ) : null}

      {item.desc ? (
        <div className="mt-3 text-sm text-slate-600 line-clamp-3 whitespace-pre-wrap">
          {item.desc}
        </div>
      ) : (
        <div className="mt-3 text-sm text-slate-400">ï¼ˆæ— æè¿°ï¼‰</div>
      )}

      <div className="mt-auto pt-4 flex items-center gap-2 flex-wrap">
        <button onClick={onOpen} className={btnClass('primary')}>é¢„è§ˆ</button>
        <a href={rawHref} target="_blank" rel="noreferrer" className={btnClass('slate')}>Raw</a>
        {item.kind === 'pdf' ? (
          <a href={browserHref} target="_blank" rel="noreferrer" className={btnClass('success')}>æµè§ˆå™¨æ‰“å¼€</a>
        ) : null}

        {canAdmin ? (
          <div className="ml-auto flex items-center gap-2">
            <button onClick={onEdit} className={btnClass('warn')}>ç¼–è¾‘</button>
            <button onClick={onDelete} className={btnClass('danger')}>åˆ é™¤</button>
          </div>
        ) : null}
      </div>
    </div>
  );
}

/* ============ Viewer Modal ============ */
function ViewerModal({ cfg, item, onClose, onReplace, mode }) {
  const [tab, setTab] = useState(item.kind === 'pdf' ? 'pdf' : 'text'); // pdf|html|text
  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState('');
  const [text, setText] = useState('');
  const scrollRef = useRef(null);

  const topicsArr = getTopicsArr(item);

  // raw for download
  const rawHref = (() => {
    if (item.storage?.owner && item.storage?.repo && item.storage?.path) {
      const branch = item.storage.branch || (cfg.pdf?.branch || 'main');
      return ghRawUrl({ owner: item.storage.owner, repo: item.storage.repo, branch, path: item.storage.path });
    }
    return buildRawUrl(cfg, item.path);
  })();

  // pdf direct open
  const pdfHref = buildPdfBrowserUrl(item.path);

  useEffect(() => {
    async function load() {
      setErr('');
      setText('');

      // PDF ç›´æ¥ iframeï¼Œä¸éœ€è¦æ‹‰ text
      if (tab === 'pdf') return;

      setLoading(true);
      try {
        const url = rawHref;
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const t = await res.text();
        setText(t);
        setTimeout(() => { try { window.hljs && window.hljs.highlightAll(); } catch {} }, 50);
      } catch (e) {
        setErr(e.message);
      } finally {
        setLoading(false);
      }
    }
    load();
  }, [tab, item.id]);

  const language = guessHighlightLanguage(item.filename || '');

  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4" onClick={onClose}>
      <div className="bg-white rounded-3xl max-w-5xl w-full border border-slate-200 shadow-2xl overflow-hidden" onClick={e=>e.stopPropagation()}>
        <div className="flex items-center justify-between px-4 py-3 border-b border-slate-200 gap-3 flex-wrap">
          <div className="min-w-0">
            <div className="font-semibold truncate">{item.title || item.filename}</div>
            <div className="text-xs text-slate-500">
              {FILE_KINDS[item.kind]?.label || 'FILE'} Â· {fmtDate(item.ts)}{topicsArr[0] ? ` Â· ${topicsArr[0]}` : ''}
            </div>
          </div>
          <div className="flex items-center gap-2 flex-wrap justify-end">
            {item.kind === 'pdf' ? (
              <button className={btnClass(tab==='pdf' ? 'success' : 'slate')} onClick={()=>setTab('pdf')}>PDF</button>
            ) : null}
            <button className={btnClass(tab==='html' ? 'primary' : 'slate')} onClick={()=>setTab('html')}>
              {item.kind === 'html' ? 'HTML' : 'Raw'}
            </button>
            <button className={btnClass(tab==='text' ? 'primary' : 'slate')} onClick={()=>setTab('text')}>
              {item.kind === 'code' ? 'Code' : 'Text'}
            </button>
            <a className={btnClass('slate')} href={rawHref} target="_blank" rel="noreferrer">Raw</a>

            {mode === 'admin' && item.kind === 'pdf' ? (
              <button className={btnClass('warn')} onClick={onReplace} title="ä¸Šä¼ æ³¨é‡Šç‰ˆå¹¶è¦†ç›–åŸæ–‡ä»¶ï¼ˆé“¾æ¥ä¸å˜ï¼‰">
                æ›¿æ¢PDF
              </button>
            ) : null}

            <button className={btnClass('danger')} onClick={onClose}>å…³é—­</button>
          </div>
        </div>

        <div ref={scrollRef} className="p-0 max-h-[75vh] overflow-auto relative">
          {tab === 'pdf' ? (
            <iframe
              className="w-full h-[75vh] bg-white"
              src={pdfHref}
              title={item.title || item.filename}
            />
          ) : loading ? (
            <div className="p-6 text-slate-600">åŠ è½½ä¸­â€¦</div>
          ) : err ? (
            <div className="p-6 text-rose-600">{err}</div>
          ) : tab === 'html' && item.kind === 'html' ? (
            <iframe
              className="w-full h-[75vh] bg-white"
              srcDoc={text}
              sandbox="allow-same-origin allow-scripts allow-popups allow-forms"
              title={item.title || item.filename}
            />
          ) : (
            <pre className="p-4 text-sm bg-[#0b1020] text-slate-50 overflow-auto">
              <code className={language ? `language-${language}` : ''}>{text}</code>
            </pre>
          )}

          {tab !== 'pdf' && !loading && !err ? (
            <button
              onClick={() => scrollRef.current && scrollRef.current.scrollTo({ top: 0, behavior: 'smooth' })}
              className="absolute right-4 bottom-4 px-3 py-1.5 rounded-full bg-slate-900 text-xs text-white shadow-lg hover:bg-slate-800"
            >
              å›åˆ°é¡¶éƒ¨
            </button>
          ) : null}
        </div>
      </div>
    </div>
  );
}

/* ============ Edit Modal ============ */
function EditItemModal({ item, onClose, onSave }) {
  const initialTopicsArr = getTopicsArr(item);
  const [title, setTitle] = useState(item.title || '');
  const [topicsInput, setTopicsInput] = useState(initialTopicsArr.join(', '));
  const [tagsInput, setTagsInput] = useState((item.tags || []).join(', '));
  const [desc, setDesc] = useState(item.desc || '');
  const [cover, setCover] = useState(null);

  function handleSubmit() {
    const topicsArr = topicsInput ? topicsInput.split(',').map(s => s.trim()).filter(Boolean) : [];
    const tagsArr = tagsInput ? tagsInput.split(',').map(s => s.trim()).filter(Boolean) : [];

    const updated = {
      ...item,
      title,
      desc,
      topics: topicsArr,
      topic: topicsArr[0] || '',
      tags: tagsArr
    };
    onSave && onSave(updated, cover);
  }

  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4" onClick={onClose}>
      <div className="bg-white rounded-3xl max-w-3xl w-full border border-slate-200 shadow-2xl overflow-hidden" onClick={e=>e.stopPropagation()}>
        <div className="flex items-center justify-between px-4 py-3 border-b border-slate-200">
          <div className="font-semibold">ç¼–è¾‘æ¡ç›®ä¿¡æ¯</div>
          <button onClick={onClose} className={btnClass('danger')}>å…³é—­</button>
        </div>

        <div className="p-4 grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-3">
            <label className="text-sm block">
              <div className="mb-1 text-slate-700">æ ‡é¢˜</div>
              <input value={title} onChange={e=>setTitle(e.target.value)} className="w-full px-3 py-2 rounded-xl border border-slate-300 bg-white text-sm" />
            </label>

            <label className="text-sm block">
              <div className="mb-1 text-slate-700">Topicsï¼ˆé€—å·åˆ†éš”ï¼‰</div>
              <input value={topicsInput} onChange={e=>setTopicsInput(e.target.value)} className="w-full px-3 py-2 rounded-xl border border-slate-300 bg-white text-sm" />
            </label>

            <label className="text-sm block">
              <div className="mb-1 text-slate-700">æ ‡ç­¾ï¼ˆé€—å·åˆ†éš”ï¼‰</div>
              <input value={tagsInput} onChange={e=>setTagsInput(e.target.value)} className="w-full px-3 py-2 rounded-xl border border-slate-300 bg-white text-sm" />
            </label>
          </div>

          <div className="space-y-3">
            <label className="text-sm block">
              <div className="mb-1 text-slate-700">æè¿°</div>
              <textarea value={desc} onChange={e=>setDesc(e.target.value)} rows={6} className="w-full px-3 py-2 rounded-xl border border-slate-300 bg-white text-sm" />
            </label>

            <label className="text-sm block">
              <div className="mb-1 text-slate-700">æ›¿æ¢å°é¢ï¼ˆå¯é€‰ï¼‰</div>
              <input type="file" accept="image/*" onChange={e=>setCover((e.target.files||[])[0]||null)} className="block w-full text-sm" />
            </label>
          </div>
        </div>

        <div className="px-4 py-3 border-t border-slate-200 flex items-center justify-end gap-2">
          <button onClick={onClose} className={btnClass('slate')}>å–æ¶ˆ</button>
          <button onClick={handleSubmit} className={btnClass('success')}>ä¿å­˜</button>
        </div>
      </div>
    </div>
  );
}

/* ============ Replace PDF Modal ============ */
function ReplacePdfModal({ item, onClose, onReplace }) {
  const [file, setFile] = useState(null);

  return (
    <div className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4" onClick={onClose}>
      <div className="bg-white rounded-3xl max-w-xl w-full border border-slate-200 shadow-2xl overflow-hidden" onClick={e=>e.stopPropagation()}>
        <div className="flex items-center justify-between px-4 py-3 border-b border-slate-200">
          <div className="font-semibold">æ›¿æ¢ PDFï¼ˆè¦†ç›–åŸæ–‡ä»¶ï¼Œé“¾æ¥ä¸å˜ï¼‰</div>
          <button onClick={onClose} className={btnClass('danger')}>å…³é—­</button>
        </div>

        <div className="p-4 space-y-3">
          <div className="text-sm text-slate-700">
            å½“å‰æ¡ç›®ï¼š<b>{item.title || item.filename}</b>
          </div>
          <div className="text-xs text-slate-500">
            é€‚ç”¨äºä½ å¯¹ PDF åšæ³¨é‡Šåï¼Œç”¨æ–°ç‰ˆæœ¬è¦†ç›–åŸ PDFï¼›ç½‘é¡µé“¾æ¥ä¿æŒä¸å˜ã€‚
          </div>

          <label className="text-sm block">
            <div className="mb-1 text-slate-700">é€‰æ‹©æ–°çš„ PDF æ–‡ä»¶</div>
            <input type="file" accept="application/pdf" onChange={e=>setFile((e.target.files||[])[0]||null)} className="block w-full text-sm" />
          </label>

          <div className="rounded-2xl border border-slate-200 bg-slate-50 p-3 text-xs text-slate-600">
            <div className="font-semibold text-slate-700 mb-1">æ³¨æ„</div>
            <ul className="list-disc pl-5 space-y-1">
              <li>è‹¥è¯¥æ¡ç›®æ˜¯æ–°ä¸Šä¼  PDFï¼ˆå¸¦ storageï¼‰ï¼Œä¼šè‡ªåŠ¨è¦†ç›–åˆ†ä»“å†…çœŸå®æ–‡ä»¶ã€‚</li>
              <li>è‹¥æ˜¯æ—§æ¡ç›®ä¸” path ä¸ºç›¸å¯¹è·¯å¾„ï¼Œä¼šåœ¨ä¸»ä»“åº“è¦†ç›–å¯¹åº”æ–‡ä»¶ã€‚</li>
              <li>è‹¥æ˜¯æ—§æ¡ç›®ä¸” path ä¸ºç»å¯¹ URL ä½†æ²¡æœ‰ storageï¼Œç³»ç»Ÿæ— æ³•å®šä½ä»“åº“è·¯å¾„ã€‚</li>
            </ul>
          </div>
        </div>

        <div className="px-4 py-3 border-t border-slate-200 flex items-center justify-end gap-2">
          <button onClick={onClose} className={btnClass('slate')}>å–æ¶ˆ</button>
          <button onClick={()=>onReplace(file)} disabled={!file} className={btnClass('warn', !file ? 'opacity-60 cursor-not-allowed' : '')}>
            è¦†ç›–æ›¿æ¢
          </button>
        </div>
      </div>
    </div>
  );
}

/* ============ Archive Sidebar (timeline style B) ============ */
function ArchiveSidebar({ items, onOpen }) {
  const sorted = useMemo(() => [...items].sort((a,b)=>(b.ts||0)-(a.ts||0)), [items]);
  const recent3 = sorted.slice(0, 3);

  // group by year->month
  const groups = useMemo(() => {
    const g = new Map(); // year -> Map(month -> items)
    for (const it of sorted) {
      const d = new Date(it.ts || 0);
      if (isNaN(d)) continue;
      const y = d.getFullYear();
      const m = d.getMonth() + 1;
      if (!g.has(y)) g.set(y, new Map());
      const gm = g.get(y);
      if (!gm.has(m)) gm.set(m, []);
      gm.get(m).push(it);
    }
    // sort inside each month
    for (const [y, gm] of g.entries()) {
      for (const [m, arr] of gm.entries()) {
        arr.sort((a,b)=>(b.ts||0)-(a.ts||0));
      }
    }
    return g;
  }, [sorted]);

  const years = useMemo(() => Array.from(groups.keys()).sort((a,b)=>b-a), [groups]);

  return (
    <aside className="bg-white rounded-3xl shadow-soft border border-slate-200 p-4">
      <div className="flex items-center justify-between mb-3">
        <div className="font-semibold text-slate-900">ğŸ“¦ å½’æ¡£</div>
        <div className="text-xs text-slate-500">æœ€è¿‘ {items.length} æ¡</div>
      </div>

      {/* recent 3 */}
      <div className="mb-4">
        <div className="text-xs font-semibold text-slate-700 mb-2">æœ€è¿‘ 3 ç¯‡</div>
        <div className="space-y-2">
          {recent3.map(it => (
            <button
              key={it.id}
              onClick={()=>onOpen(it)}
              className="w-full text-left p-3 rounded-2xl border border-slate-200 hover:bg-slate-50"
            >
              <div className="text-sm font-semibold text-slate-900 line-clamp-1">{it.title || it.filename}</div>
              <div className="text-xs text-slate-500 mt-0.5">{fmtDate(it.ts)} Â· {(getTopicsArr(it)[0] || 'â€”')}</div>
            </button>
          ))}
          {!recent3.length ? <div className="text-sm text-slate-500">æš‚æ— æ¡ç›®</div> : null}
        </div>
      </div>

      <div className="border-t border-slate-200 pt-4">
        <div className="text-xs font-semibold text-slate-700 mb-2">æ—¶é—´è½´ï¼ˆä¸‹æ»‘æŸ¥çœ‹æ›´å¤šï¼‰</div>

        <div className="max-h-[520px] overflow-auto scrollbar-thin pr-2">
          <div className="tl">
            {years.map(year => {
              const monthsMap = groups.get(year);
              const months = Array.from(monthsMap.keys()).sort((a,b)=>b-a);
              return (
                <div key={year} className="mb-5 relative">
                  <div className="tl-dot" style={{ top: 2 }}></div>
                  <div className="pl-4">
                    <div className="text-base font-semibold text-slate-900">{year}</div>
                    <div className="mt-2 space-y-3">
                      {months.map(month => {
                        const arr = monthsMap.get(month) || [];
                        return (
                          <div key={month} className="relative">
                            <div className="tl-dot sm" style={{ top: 6 }}></div>
                            <div className="pl-4">
                              <div className="text-sm font-semibold text-slate-800">{String(month).padStart(2,'0')}</div>
                              <div className="mt-1 space-y-1">
                                {arr.slice(0, 6).map(it => (
                                  <button
                                    key={it.id}
                                    onClick={()=>onOpen(it)}
                                    className="w-full text-left text-sm text-slate-700 hover:text-slate-900 hover:underline line-clamp-1"
                                    title={it.title || it.filename}
                                  >
                                    {String(new Date(it.ts||0).getDate()).padStart(2,'0')} Â· {it.title || it.filename}
                                  </button>
                                ))}
                                {arr.length > 6 ? (
                                  <div className="text-xs text-slate-400">â€¦ è¿˜æœ‰ {arr.length - 6} æ¡</div>
                                ) : null}
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      </div>
    </aside>
  );
}

/* ============ Footer ============ */
function Footer() {
  return (
    <footer className="mt-auto border-t border-slate-200 bg-white">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 text-xs text-slate-500 flex flex-wrap gap-2 items-center">
        <span>Â© Repo Library</span>
        <span>Â·</span>
        <span>å•æ–‡ä»¶ HTMLï¼ˆReact + Tailwindï¼‰</span>
        <span>Â·</span>
        <span>PDF åˆ†ä»“ï¼ˆAæ–¹æ¡ˆï¼‰+ æ›¿æ¢PDF + å½’æ¡£æ—¶é—´è½´</span>
      </div>
    </footer>
  );
}

/* ============ Mount ============ */
ReactDOM.createRoot(document.getElementById('root')).render(<App />);

</script>
</body>
</html>
